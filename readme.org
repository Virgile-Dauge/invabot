#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+TITLE: Invabot

* Documentation des r√¥les
#+begin_export html
<script async src="https://nwdb.info/embed.js"></script>
#+end_export
Cette section a pour objectif de pr√©senter les diff√©rents r√¥les utiles
en invasion. Chaque r√¥le comporte des composantes indispensables,
illustr√©es par le sigle suivant : /(obligatoire)/. Afin de mieux
ma√Ætriser la r√©partition des r√¥les, il sera demand√© aux joueurs
d'√©valuer leur pertinence pour chacun de ces r√¥les.

Un joueur peut s'estimer :

- Capable :: S'il r√©pond √† tous les crit√®res tagu√©s */(obligatoire)/*
- Opti :: S'il r√©pond a tous les crit√®res tagu√©s */(obligatoire)/* *ET* */(recommand√©)/*.

** Arc
- *Objectif* :: DPS les *t√™tes*, les *boss*, les engins de si√®ges et
  AoE les trashs, dans cet ordre de priorit√©.
- *Arme principale* :: Arc 580 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] */(obligatoire)/* et [[https://nwdb.info/db/perk/perkid_weapon_empoweroncrit][Keenly
  Empowered]] */(recommand√©)/*. [[https://nwdb.info/build?skills=4-iw75uo-ngewxw][Build arc]] */(recommand√©)/*
- *Arme secondaire* :: Arme d√©buff distance comme la hachette ou la lance avec [[https://nwdb.info/db/perk/perkid_ability_spear_javelin][Sundering Javelin]] sur pi√®ce d'armure */(recommand√©)/*
- *Armure et perks* :: L√©g√®re avec perks pour l'arc[[https://nwdb.info/db/perk/perkid_ability_bow_poisonshot][ Enfeebling Poison Shot]] et [[https://nwdb.info/db/perk/perkid_ability_bow_rapidshot][Penetrating Rapid Shot]] */(recommand√©)/*
[[https://nwdb.info/db/perk/perkid_ability_spear_javelin][      Sundering Javelin]] */(recommand√© si lance en secondaire)/*

** Mousquet

- *Objectif* :: DPS les *t√™tes* et les *boss*, dans cet ordre de priorit√©.
- *Arme principale* :: Mousquet 570 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] */(obligatoire)/* et
  [[https://nwdb.info/db/perk/perkid_weapon_dmgbasic][Enchanted]] */(recommand√©)/*  [[https://nwdb.info/build?skills=6-nm5y04-qtbfgg][Build Mousquet]] */(recommand√©)/*
- *Armure et perks* :: L√©g√®re avec perks pour le mousquet [[https://nwdb.info/db/perk/perkid_ability_musket_shootersstance][Empowering Shooter's
  Stance]] */(recommand√©)/*.

** Anti-Trash

- *Objectif* :: Emp√™cher les *trash-mobs* d'atteindre les autres joueurs et les portes.
- *Arme principale* :: Hache double 580 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] */(obligatoire)/*
  [[https://nwdb.info/db/item/sapphirecutt4][Pristine Sapphire]] */(obligatoire)/* et [[https://nwdb.info/db/item/sapphirecutt4 [[https://nwdb.info/db/perk/perkid_weapon_empoweroncrit][Keenly Empowered]] (recommand√©).
  [[https://nwdb.info/build?skills=8-j1mxog-kc3hhg][Build Hache double]] */(obligatoire)/*
- *Arme secondaire* :: Arme C√†C, Marteau pour le contr√¥le ?
- *Armure et perks* :: Lourde */(recommand√©)/* [[https://nwdb.info/db/perk/perkid_ability_greataxe_gravitywell][Insatiable Gravity Well]]
  */(obligatoire)*/ [[https://nwdb.info/db/perk/perkid_ability_greataxe_maelstrom][Enfeebling Maelstrom]] et [[https://nwdb.info/db/perk/perkid_ability_greataxe_whirlwind][Fortifying Whirlwind]]
  */(recommand√©)/* et pour de la survivabilit√© [[https://nwdb.info/db/perk/perkid_armor_defcorrupted][Corrupted Ward]] sur
  quelques pi√®ces */(recommand√©)/*

** DPS debuff

- *Objectif* :: Appliquer */rend/* et */weaken/* aux boss et les DPS
- *Arme principale* :: Lance 580 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] */(obligatoire)/* et
  [[https://nwdb.info/db/perk/perkid_weapon_empoweroncrit][Keenly Empowered]] ou [[https://nwdb.info/db/perk/perkid_weaponmelee_dmgback][Rogue]] */(recommand√©)/*. [[https://nwdb.info/build?skills=10-l71p4w-tsmm2s][Build lance]]
  */(obligatoire)/*
- *Arme secondaire* :: Arc pr√©f√©r√©, mais peut √™tre une arme de C√†C.
- *Armure* :: L√©g√®re avec perks [[https://nwdb.info/db/perk/perkid_ability_spear_javelin][Sundering Javelin]] */(obligatoire)/*
  [[https://nwdb.info/db/perk/perkid_ability_spear_skewer][Enfeebling Skewer]] */(obligatoire)/* [[https://nwdb.info/db/perk/perkid_ability_spear_perforate][Fortifying Perforate]] */(recommand√©)/*
  et pour de la survivabilit√© [[https://nwdb.info/db/perk/perkid_armor_defcorrupted][Corrupted Ward]] sur quelques pi√®ces */(recommand√©)/*

** Pustule boy
- *Objectif* :: Tirer en *priorit√© sur les pustules* qui se forment
  lors de l'impact d'un bison √† l'int√©rieur du fort. Aider au centre.

- *Arme principale* :: Arme distante */(obligatoire)/*, les armes
  N√©ant/Arc/Feu */(recommand√©)/* sont plus efficaces dans ce r√¥le
  gr√¢ce √† une meilleure cadence de tir.
- *Arme secondaire* ::  Arc/Mousquet */(recommand√©)/*

** R√©parateur
- *Objectif* :: G√©rer les ressources et *r√©parer les portes*.
- *Arme principale* :: Hachette avec [[https://nwdb.info/db/ability/ult_passive_hatchet_immortalwhen0hp][Defy Death]] */(recommand√©)/*
- *Arme secondaire* :: Arme avec mobilit√© */(recommand√©)/*

PS: Si vous n'avez jamais jou√© Hachette, il suffit de d√©bloquer 12
points de comp√©tence. C'est assez rapide et vous n'avez pas besoin
d'une arme haut niveau/particuli√®re.

** Artilleur

- *Objectif* :: Tuer les bombers, les tireurs, les artilleries
  ennemies et les trash mob, en respectant cet ordre de priorit√©.

- *Arme principale* :: √âp√©e avec la comp√©tence [[https://nwdb.info/db/ability/ultimate_sword_swordmaster][Leadership]] */(obligatoire)/*
- *Arme secondaire* :: B√¢ton de feu/vie/hachette */(recommand√©)/*

PS: Si vous n'avez jamais jou√© l'√©p√©e, il suffit de d√©bloquer 12
points de comp√©tence. C'est assez rapide et vous n'avez pas besoin
d'une arme haut niveau/particuli√®re.
** Heal
- *Objectif* :: Maintenir l'√©quipe *Anti-trash* en vie en priorit√©
  puis emp√™cher les *trash-mobs* d'atteindre les autres joueurs et les
  portes.
- *Arme principale* :: B√¢ton de vie 580 GS min */(obligatoire)/* avec [[https://nwdb.info/db/perk/perkid_weaponlife_healoutgoing][Blessed]]
  */(recommand√©)/*
- *Arme secondaire* :: Hache double avec [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] et [[https://nwdb.info/db/item/ambercutt4][Pristine
  Amber]] */(recommand√©)/* [[https://nwdb.info/build?skills=8-j1mxog-kc3hhg][Build Hache double]] */(recommand√©)/*

  OU

  Gantelet du n√©ant

- *Armure* :: [[https://nwdb.info/db/perk/perkid_armor_defcorrupted][Corrupted Ward]] sur quelques pi√®ces */(recommand√©)/*


** Mage AOE

- *Objectif* :: DPS les *boss* dans les phases de fin, quand ils
  s'accumulent sur les portes.
- *Arme principale* :: B√¢ton de feu 580 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] avec [[https://nwdb.info/db/item/sapphirecutt4][Pristine Sapphire]] */(obligatoire)/*
  et [[https://nwdb.info/db/perk/perkid_weapon_empoweroncrit][Keenly Empowered]] */(recommand√©)/*.
- *Arme secondaire possible* :: Mousquet [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] et [[https://nwdb.info/db/perk/perkid_weapon_dmgbasic][Enchanted]] avec
  [[https://nwdb.info/db/item/sapphirecutt4][Pristine Sapphire]] */(recommand√©)/*
  OU
  Gantelet de glace pour bloquer les boss
- *Armure* :: L√©g√®re


* Bot
** Concept :

 Le bot √† pour objectif de g√©n√©rer une composition d'arm√©e √† partir des
 50 joueurs s√©lectionn√©s al√©atoirement par le jeu.

** Configuration

 La configuration du bot passera par un fichier json unique, contenant
 le corps des diff√©rents messages √† transmettre ainsi que les adresses
 des Gdoc √† lire.
 #+begin_src json :tangle config.json
   {
   "ids": {
       "role": 917546013248606238,
       "leads": 928316217297612810
   },
   "doc":{
       "url": "https://virgile-dauge.github.io/invabot/"
   },
   "imgs": {
       "layout": "https://cdn.discordapp.com/attachments/917547596640296990/922901028519706674/layout.png"
   },
   "embeds": {
       "panneau": {
           "title": "Confirme ta s√©l√©ction √† l'invasion de",
           "color": 2003199,
           "description": "R√©agis avec :ballot_box_with_check: √† ce message **uniquement si tu es d√©j√† dans le fort**. Attention, retourne vite en jeu, l'auto-AFK kick est rapide (2min). \n\n Si tu as r√©agi par erreur, merci de d√©cocher ta r√©action. :wink: \n\n*(Et si vous aussi vous pensez que bakhu est la meilleure guilde)*"
       },
       "dm": {
           "title": "Dis nous tout !",
           "color": 2003199,
           "description": "Tu es inscrit en invasion, mais tu n'as pas renseign√© **les r√¥les** que tu peux jouer. Il n'est donc par cons√©quent pas possible de t'assigner un poste automatiquement. Allez, file remplir [ce document]("
       },
       "change": {
           "title": "Tu as chang√© ton discord TAG :/",
           "color": 2003199,
           "description": "Il faut mettre √† jour tes infos. Allez, file remplir [ce document]("
       },
       "help": {
           "title": "Manuel d'utilisation d'invabot",
           "color": 2003199,
           "fields": [{"name": "Blue Team", "value": "Something", "inline" : "True"}]
       }
   },
   "gdoc": {
       "url": "https://docs.google.com/spreadsheets/d/1FgtMvUQbLxP7qvXt2tnVwFFyX9KWnuREHu7o0RtX13M/",
       "strats": {
           "Principale": "Strat_principale",
           "Secours": "Strat_secours"
       },
       "page_roster": "Roster",
       "form": "https://forms.gle/G9LizybajjVxCw6JA"
   }
   }
 #+end_src



** Utilitaires
*** D√©pendances
#+begin_src python :tangle bot.py

   import pandas as pd
   from algo import build_comp

#+end_src
*** Chargement de la config

 Le chargement de cette config se fera pour l'instant une seule fois au
 d√©marrage du bot.
#+name: config
 #+begin_src python :tangle bot.py
   # Chargement de la config du bot
   import json
   with open('config.json', 'r') as datafile:
       config = json.load(datafile)
 #+end_src

 #+begin_src python :tangle bot.py
   # Chargement de la config du bot
   import json
   with open('config.json', 'r') as datafile:
       config = json.load(datafile)
 #+end_src

*** Persistance

 Le chargement des donn√©es
#+name: data
 #+begin_src python
  # Chargement de la config du bot
  def load_data(path='data.json'):
      with open(path, 'r') as datafile:
          return json.load(datafile)
  def save_data(data, path='data.json'):
      with open(path, 'w') as datafile:
          json.dump(data, datafile, sort_keys=True, indent=4)
  def add_participation(participants):
      #print(participants)
      data = load_data()
      for p in participants:
          if p in data:
              data[p] +=1
          else:
              data[p] = 1
      #print(data)
      save_data(data)
 #+end_src
*** Chargement du token
#+Name: token
 #+begin_src python :tangle bot.py
   # Chargement du token
   with open('bot.token', 'r') as datafile:
       token = datafile.read()
 #+end_src
*** Identifiant

 Il est n√©cessaire d'avoir un identifiant unique entre discord et le
 gdoc pour faire le lien. Discord g√®re les identifiants sous forme d'un
 entier appel√© /snowflake/. Toutefois, il est difficilement accessible
 pour les joueurs, et ce sont les joueurs qui vont devoir renseigner
 leur identifiant unique sur le gdoc. Il est donc plus simple
 d'utiliser ici le *discord tag*, par exemple `Virgile#1234`.

 Je propose ici une rapide fonction d'aide pour r√©cup√©rer le dtag
 depuis un objet /discord.User/ :
 #+name: dtag
 #+begin_src python :tangle bot.py
   def dtag(user):
       return f'{user.name}#{user.discriminator}'
 #+end_src

*** R√©cup√©ration du roster
#+name: get_roster
 #+begin_src python :tangle bot.py
   def get_roster(config):
       url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={config['gdoc']['page_roster']}"
       #return pd.read_csv(url).iloc[1:, 0:6].dropna().set_index('dtag')
       return pd.read_csv(url).set_index('dtag')
 #+end_src

 #+begin_example
                 Pseudo             0           1     2           3
 dtag
 Chopekk#1234   Chopekk    DPS-Debuff    Mousquet  Heal  Anti-trash
 Virgile#2345  virgilio      Mousquet  Anti-trash  R√©pa        Arti
 Virgile#3456     Tezig  Lance-flamme  Anti-trash   Arc        Arti
 Carlito#4567      Slua    Anti-trash        Arti  R√©pa       Aucun
 #+end_example
*** R√©cup√©ration de la strat

 #+begin_src python :tangle bot.py
   def get_strat(config, strat=None):
       if strat is None:
           url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={config['gdoc']['page_strat']}"
       else:
           url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={config['gdoc']['page_strat']}"
       return pd.read_csv(url).iloc[0:5, 0:12]
 #+end_src

 #+begin_example
      Groupe 1 Groupe 2    Groupe 3 Groupe 4    Groupe 5    Groupe 6    Groupe 7    Groupe 8 Groupe 9     Groupe 10
 0  Anti-Trash      Arc  Anti-Trash      Arc  Anti-Trash    Mousquet  Anti-Trash    Mousquet     R√©pa  Lance-flamme
 1        Heal      Arc        Heal      Arc        Heal    Mousquet        Heal    Mousquet     R√©pa  Lance-flamme
 2  DPS-Debuff      Arc  DPS-Debuff      Arc  DPS-Debuff    Mousquet  DPS-Debuff    Mousquet     R√©pa  Lance-flamme
 3  DPS-Debuff      Arc  DPS-Debuff      Arc  DPS-Debuff  DPS-Debuff  DPS-Debuff  DPS-Debuff     R√©pa  Lance-flamme
 4        Arti     Arti        Arti     Arti        Arti        Arti        Arti        Arti     R√©pa  Lance-flamme
 #+end_example



* Algo
D√©pendances
#+begin_src python :tangle algo.py
import numpy as np
import pandas as pd
from scipy.optimize import linear_sum_assignment
#+end_src

R√©cup√©ration du roster de test
 #+begin_src python :tangle algo.py
   def get_test_roster():
       page= 'Roster'
       url = f"https://docs.google.com/spreadsheets/d/1FgtMvUQbLxP7qvXt2tnVwFFyX9KWnuREHu7o0RtX13M/gviz/tq?tqx=out:csv&sheet={page}"
       #return pd.read_csv(url).iloc[:, 0:16].dropna().set_index('dtag')
       return pd.read_csv(url).set_index('dtag')
 #+end_src

#+begin_src python :tangle algo.py
    def get_test_strat():
      page= 'Strat'
      url = f"https://docs.google.com/spreadsheets/d/1vDZ_p6Bq2oyyY0CV1SQ0FBRtJoGbtiurM9cOQWHJ-qo/gviz/tq?tqx=out:csv&sheet={page}"
      return pd.read_csv(url).iloc[0:5, 0:12]
#+end_src

#+RESULTS:
: None

 Identification des R√¥les :
 #+begin_src python :tangle algo.py :noweb yes

   def build_comp(roster, strat, config):
       roles = {}
       for index, row in strat.iterrows():
           for v in row:
               v = v.split(' ')[0]
               if v in roles:
                   roles[v] += 1
               else:
                   roles[v] = 1

       max_roles = {k: v.max() for k,v in roster.iteritems()}
       <<cout>>
       <<res>>
       <<comp>>
 #+end_src

Cr√©ation des colonnes avec les noms de r√¥les, les lignes avec les noms
de joueurs, et de la matrice de co√ªts.
 #+name: cout
 #+begin_src python

   cols = [k for k, v in roles.items() for _ in range(v)]
   rows = roster.index

   C = np.zeros((len(rows), len(cols)), dtype=int)

   for i, r in enumerate(rows):
       for j, c in enumerate(cols):
           C[i, j] = roster.at[r, c]
 #+end_src


R√©solution du probl√®me d'affectation avec la maximisation suivante :
$$max \sum_{i} \sum_{j} C_{i,j} X_{i,j}$$
#+name: res
#+begin_src python

row_ind, X = linear_sum_assignment(C, maximize=True)
score = C[row_ind, X].sum()
assignent = {p: cols[t] for p, t in zip(rows, X)}

#+end_src

Analyse des r√©sultats
#+begin_src python :tangle no
  for k, v in assignent.items():
      print(k, v, roster.at[k, v])

#+end_src

Remplissage du tableau
#+name: comp
#+begin_src python
  filed_roles = {}
  for k, v in assignent.items():
      #print(k, v)
      if v not in filed_roles:
          filed_roles[v] = [k]
      else:
          filed_roles[v] += [k]

  comp = strat.copy()
  for i, row in comp.iterrows():
      for j, v in row.items():
          label = ''
          if len(v.split(' ')) > 1:
              v, label = v.split(' ')
          if v in filed_roles and filed_roles[v]:
              p = filed_roles[v].pop()
              role_txt = f"[{comp.at[i, j]}]({config['doc']['url']})"
              #if role_txt in config['doc']:
              #    role_txt = f"[{role_txt}]({config['doc'][url]})"
              comp.at[i, j] = f'{p} *{role_txt}* {roster.at[p, v] / max_roles[v]:.1f}'
  return comp
#+end_src

** Test algo

#+begin_src python :tangle algo.py

  if __name__ == '__main__':
      roster = get_test_roster().set_index('Pseudo IG')
      roster.to_csv('roster.csv')
      print(roster)
      strat = get_test_strat()
      strat.to_csv('strat.csv')
      print(strat)
      print(build_comp(roster, strat))
#+end_src
**** Filtrage des joueurs
 #+begin_src python :tangle no
 keys_to_extract = []
 a_subset = {key: players[key] for key in keys_to_extract}
 #+end_src


* TODO bot avec Disnake

** Corp
#+begin_src python :tangle bot.py :noweb tangle
  import pandas as pd
  from algo import build_comp

  import disnake
  from disnake.ext import commands
  from disnake import Embed, Emoji


  <<dtag>>
  <<get_roster>>
  <<config>>
  def list_to_field(l):
      f = 'aucun'
      if l:
          f = ''
          for u in l:
              f += u + '\n'
          if len(f)>1023:
              return f[:1000]+'...'
          return f

  def unique(l):
      u = []
      for r in l:
          if r not in u:
              u +=[r]
      return u

  def main():
      bot = commands.Bot(
          intents=disnake.Intents().all(),
          test_guilds=[906630964703289434], # Optional
          sync_commands_debug=True
      )
      <<data>>
      <<dis_transfert>>
      <<dis_inva_cmd>>
      <<dis_instance>>
      <<dis_verif>>
      <<check_user>>
      <<update_instance_add>>
      <<update_instance_rm>>
      <<on_reaction>>
      <<on_reaction_rm>>
      <<on_voice_state_update>>
      bot.run(token=open("bot.token").read()[:-1])

  if __name__ == "__main__":
      main()
#+end_src

** Commande inva
#+name: dis_inva_cmd
 #+begin_src python :noweb yes
  villes = ["Bief de N√©r√©caille", "Boisclair", "Eaux F√©tides", "Gr√© du vent",
            "Ile des Lames", "Levant", "Haute-Chute", "Marais des Trames",
            "Rive tourment√©e", "Val des Larmes", "Falaise du roy"]

  async def autocomp_villes(inter: disnake.ApplicationCommandInteraction, user_input: str):
      return [ville for ville in villes if ville.lower().startswith(user_input.lower())]

  async def tags_from_id(ctx, msg_id):
      msg = await ctx.channel.fetch_message(msg_id)
      selected = await msg.reactions[0].users().flatten()
      return [dtag(u) for u in selected][1:]

  class CompTrigger(disnake.ui.View):
      options = [disnake.SelectOption(label=k, value=v) for k, v in config['gdoc']['strats'].items()]
      options[0].default = True
      def __init__(self, origin, **kwargs):
          super().__init__(**kwargs)
          self.origin = origin
          self.strat = config['gdoc']['strats']['Principale']

      @disnake.ui.select(options=options)
      async def compo(self, select: disnake.ui.Select, inter: disnake.MessageInteraction):
          self.strat=select.values[0]
          await inter.response.defer()

      @disnake.ui.button(label='Composition', style=disnake.ButtonStyle.blurple)
      async def trigger(self, button: disnake.ui.Button, inter: disnake.MessageInteraction):
          #await interaction.delete_original_message()
          await inter.response.defer()
          self.stop()


  @bot.slash_command(
      scope=906630964703289434,
  )
  async def invasion(
          ctx: disnake.ApplicationCommandInteraction,
          ville: str=commands.Param(autocomplete=autocomp_villes)):
      """ G√©n√©re un tableau d'inscription dans le channel actuel

          Parameters
          ----------
          ville: La ville o√π se d√©roule l'invasion
      """

      embed = Embed(
          title=f'Invasion de {ville}',
          color=2003199,
          description="R√©agis avec :ballot_box_with_check: √† ce message **uniquement si tu es d√©j√† dans le fort**. Attention, retourne vite en jeu, l'auto-AFK kick est rapide (2min). \n\n Si tu as r√©agi par erreur, merci de d√©cocher ta r√©action. :wink:",
      )
      embed.set_footer(text='Invasion')

      # Envoi du message et ajout de la r√©action
      await ctx.send(embed=embed)
      msg = await ctx.original_message()
      await msg.add_reaction('‚òë')

      # Envoi d'un message cach√© √† l'invocateur
      trigger = CompTrigger(msg.id, timeout=10*60)
      await ctx.send("Calcul", view=trigger, ephemeral=True)

      # Attente du d√©clanchement pas l'invocateur
      await trigger.wait()

      # R√©cup√©ration du message originel complet
      msg = await ctx.channel.fetch_message(msg.id)

      selected = await msg.reactions[0].users().flatten()

      selected_tags = [dtag(u) for u in selected if dtag(u) != 'Invasion#5489']
      #selected_tags = [dtag(u) for u in selected][1:]

      # R√©cup√©ration des don√©nes du Gdoc roster
      roster = get_roster(config)

      # Joueurs s√©l√©ctionn√©s n'ayant pas rempli le Gdoc
      not_registered = [u for u in selected_tags if u not in roster.index]

      # Filtrage du roster avec les joueurs s√©l√©ctionn√©s
      roster = roster.filter(items=selected_tags, axis=0).set_index('Pseudo IG')

      add_participation(roster.index)

      strat=trigger.strat

      # R√©cup√©ration de la strat
      url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={strat}"

      page = pd.read_csv(url)
      strat_df = page.iloc[0:5, 0:10]
      img_url = page.iat[5, 1]

      comp = build_comp(roster, strat_df, config)
      def gen_embed(comp):
          e = Embed(title="Composition d'arm√©e")
          for k, v in comp.iteritems():
              f = ''
              for p in v.to_list():
                  f += str(p) + '\n'
              e.add_field(name=k, value=f, inline=True)
          return e

      embed = gen_embed(comp)
      embed.title = f"Invasion de {ville}, {strat} :"
      #embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)
      embed.color = 2003199
      embed.set_thumbnail(url=img_url)
      await ctx.send(embed=embed, delete_after=60*25)

 #+end_src
** Commande verif
#+name: dis_verif
 #+begin_src python
  @bot.slash_command(
      description="V√©rification du Gdoc et mise √† jour des r√¥les",
      scope=906630964703289434,
  )
  async def verif(ctx):
      """ Attribue les r√¥les
      """

      guild = ctx.guild
      lead_role = guild.get_role(config["ids"]["leads"])

      # R√©cup√©ration des don√©nes du Gdoc roster
      roster_df = get_roster(config)
      roster = list(roster_df.index)

      members = {dtag(m): m for m in guild.members}

      role = guild.get_role(config["ids"]["role"])
      verified = [dtag(m) for m in role.members]

      added = []
      wrong = []
      for u in roster:
         if u not in members:
             wrong += [u]
         elif u not in verified:
             if role is None:
                 # Make sure the role still exists and is valid.
                 return

             try:
                 # Finally, add the role.
                 await members[u].add_roles(role)
                 added += [u]
             except discord.HTTPException:
                 # If we want to do something in case of errors we'd do it here.
                 pass

      removed = []
      for u in verified:
          if u not in roster:
              try:
                  # Finally, remove the role.
                  await members[u].remove_roles(role)
                  removed += [u]

                  # Send DM to user
                  embed = Embed.from_dict(config["embeds"]["change"])
                  embed.description += f'{config["gdoc"]["form"]}) ***!***'
                  await members[u].send(embed=embed)
              except discord.HTTPException:
                  # If we want to do something in case of errors we'd do it here.
                  pass

      def add_IG(l, roster_df):
          return [f"{i} | {roster_df.loc[i]['Pseudo IG']}" for i in l]
      wrong = add_IG(wrong, roster_df)
      added = add_IG(added, roster_df)
      embed = Embed()
      embed.title = f'V√©rification du gdoc'
      embed.color = 2003199
      #embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)

      embed.add_field(name="Joueurs nouvellement v√©rifi√©s", value=list_to_field(added), inline=False)
      embed.add_field(name="Discord tag dans le Gdoc ne correspondant √† aucun membre du discord", value=list_to_field(wrong), inline=False)
      embed.add_field(name=f"Joueurs ayant chang√© de Discord tag (r√¥le {role} supprim√©)", value=list_to_field(removed), inline=False)
      await ctx.channel.send(embed=embed, delete_after=20*60)
      #print(added, wrong)


 #+end_src
** Commande transfert
#+name: dis_transfert
 #+begin_src python

  async def autocomp_sources(ctx: disnake.ApplicationCommandInteraction, user_input: str):
      voices = [v for v in ctx.guild.voice_channels if v.members]
      return [v.name for v in voices if v.name.lower().startswith(user_input.lower())]

  async def autocomp_destinations(ctx: disnake.ApplicationCommandInteraction, user_input: str):
      voices = ctx.guild.voice_channels
      return [v.name for v in voices if v.name.lower().startswith(user_input.lower())]
      #return [ville for ville in villes if user_input.lower() in ville]
  @bot.slash_command()
  async def transfert(ctx: disnake.ApplicationCommandInteraction,
                      source: str=commands.Param(autocomplete=autocomp_sources),
                      destination: str=commands.Param(autocomplete=autocomp_destinations)):
      """D√©place les joueurs d'un salon vocal source √† un salon destinatoin

          Parameters
          ----------
          source: La ville o√π se d√©roule l'invasion
          destination: La ville o√π se d√©roule l'invasion
      """
      voices = {v.name: v for v in ctx.guild.voice_channels}
      dest = voices[destination]
      users = voices[source].members
      await ctx.send(content=f'{len(users)} Utilisateurs vont √™tre d√©plac√©s dans le salon ***{destination}***', ephemeral=True)
      [await u.move_to(dest) for u in users]


 #+end_src

** Commande Instance
#+name: dis_instance
 #+begin_src python
  lieux = ["Lazarus", "G√®nese", "Sir√®ne"]

  async def autocomp_lieux(inter: disnake.ApplicationCommandInteraction, user_input: str):
      return [l for l in lieux if l.lower().startswith(user_input.lower())]

  @bot.slash_command()
  async def instance(ctx: disnake.ApplicationCommandInteraction,
                     lieu: str=commands.Param(autocomplete=autocomp_lieux),
                     heure: str=commands.Param(default=None),
                     prix: str=commands.Param(default=None)):
      """Cr√©e un panneau d'inscription √† une instance

          Parameters
          ----------
          lieu: La ville o√π se d√©roule l'instance
          heure: L'heure √† laquelle se d√©roule l'instance
          prix: Le prix par personne, gratuit c'est cool aussi ;)
      """
      embed = Embed()
      embed.title = f'Instance {lieu}'
      embed.description = ''
      if heure:
          embed.description += f' üïê {heure}\n'
      if prix:
          embed.description += f' üí∞ {prix}\n'
      embed.description += f'Propos√©e par {ctx.user.mention}\n'
      embed.color = 2003199

      roles = ['üõ°', '‚öî', '‚öî', '‚öî','‚õë']
      players = ['libre']*len(roles)
      embed.add_field(name="R√¥les", value=list_to_field(roles), inline=True)
      embed.add_field(name="Joueurs", value=list_to_field(players), inline=True)
      embed.set_footer(text='Instance')
      # Envoi du message et ajout de la r√©action
      await ctx.send(embed=embed)
      msg = await ctx.original_message()


      for r in unique(roles):
          await msg.add_reaction(r)
      await msg.add_reaction('‚úÖ')
      await msg.add_reaction('‚ùå')
 #+end_src
** Gestion des r√©actions aux messages

Certain des messages issus des commandes du bot n√©cessitent une
analyse des r√©actions des utilisateurs.

Les r√©actions aux messages sont centralis√©es, et un *callback* unique
est appel√© d√®s qu'une utilisateur r√©agit, ind√©pendamment du
message. Or,nous ne voulons pas analyser les r√©actions aux messages
qui ne sont pas issus d'une commande du bot.

Il nous faut donc un m√©canisme pour identifier si le message attach√©
est d'un type int√©ressant et si oui, comment l'analyser. Il serait
possible de stocker en m√©moire tous les messages issus de commandes
envoy√©s, mais pour me simplifier la vie je pr√©f√©re embarquer cette
information dans les messages.

Malheureusement, je n'ai pas trouv√© de champ non utilis√© dans la
classe message. J'ai donc d√©cid√© de stocker le type directement dans
le contenu du message. Plus particuli√®rement dans le *footer* de
l'embed du message.
*** On reaction add
 #+name: on_reaction
  #+begin_src python
   @bot.event
   async def on_reaction_add(reaction, user):
        if user == bot.user:
            return
        if not reaction.message.embeds:
            return
        msg_type = reaction.message.embeds[-1].footer.text

        if msg_type == 'Invasion':
            await check_user_role(reaction, user)
            return
        if msg_type == 'Instance':
            await update_instance(reaction, user)
            return

 #+end_src
*** On reaction remove
 #+name: on_reaction_rm
  #+begin_src python
   @bot.event
   async def on_reaction_remove(reaction, user):
        if user == bot.user:
            return
        if not reaction.message.embeds:
            return
        msg_type = reaction.message.embeds[-1].footer.text
        if msg_type == 'Invasion':
            await update_invasion(reaction)
            return
        if msg_type == 'Instance':
            await update_instance_rm(reaction, user)
            return

 #+end_src
*** On s'assure que le joueur soit enregistr√©
#+name: check_user
#+begin_src python
  async def update_invasion(reaction):
      selected = await reaction.message.reactions[0].users().flatten()
      embed = reaction.message.embeds[-1]
      embed.clear_fields()
      embed.add_field(name="Enregistr√©s :", value=len(selected)-1, inline=True)
      await reaction.message.edit(embed=embed)

  async def check_user_role(reaction, user):
      # R√©cup√©ration des don√©nes du Gdoc roster
      df = get_roster(config)
      if dtag(user) not in df.index:
          embed = Embed.from_dict(config["embeds"]["dm"])
          embed.description += f'{config["gdoc"]["form"]}) ***!***'
          try:
              await user.send(embed=embed)
          except disnake.errors.HTTPException as e:
              pass
      else:
          guild = reaction.message.guild
          role = guild.get_role(config["ids"]["role"])

          await update_invasion(reaction)

          await user.edit(nick=df.at[dtag(user), "Pseudo IG"])
          if role is None:
              # Make sure the role still exists and is valid.
              return
          try:
              # Finally, add the role.
              await user.add_roles(role)
          except disnake.HTTPException:
              # If we want to do something in case of errors we'd do it here.
              ...
#+end_src

*** Gestion ajout r√©action message Instance
#+name: update_instance_add
#+begin_src python
  def instance_data(reaction):
      fields = {e.name: e.value.split('\n') for e in reaction.message.embeds[-1].fields}
      return fields['R√¥les'], fields['Joueurs']

  async def update_instance_embed(reaction, roles, joueurs):
      # R√©cup√©ration et mise √† jour du message initial
      embed = reaction.message.embeds[-1]
      embed.clear_fields()
      embed.add_field(name="R√¥les", value=list_to_field(roles), inline=True)
      embed.add_field(name="Joueurs", value=list_to_field(joueurs), inline=True)
      await reaction.message.edit(embed=embed)

  async def update_instance(reaction, user, add=True):
      message = reaction.message
      cmd_author = message.interaction.user

      roles, joueurs = instance_data(reaction)

      if reaction.emoji == '‚úÖ':
          if user == cmd_author:
              # Create vocal and swap users

              categories = message.guild.categories
              category = disnake.utils.find(lambda c: c.id == 948167052722573322, categories)
              voice = await category.create_voice_channel(f'Instance de {user.display_name}')

              ids = [int(j[3:-1]) for j in joueurs if j != 'libre']

              users = await message.guild.getch_members(ids, presences=True)

              for u in users:
                  if u.voice:
                      await u.move_to(voice)
                  else:
                      invite = await voice.create_invite()
                      await u.send(f"L'instance a d√©marr√©, rejoins ici : {invite} ", embed=message.embeds[-1])
              await message.delete(delay=60)
              return

      if reaction.emoji == '‚ùå':
          if user == cmd_author:
              await message.delete()
          return

      if user.mention not in joueurs:
          for i, r in enumerate(roles):
              if reaction.emoji == r and joueurs[i] == 'libre':
                  joueurs[i] = user.mention
                  break

      await update_instance_embed(reaction, roles, joueurs)
#+end_src

*** Gestion annulation r√©action message Instance
#+name: update_instance_rm
#+begin_src python

  async def update_instance_rm(reaction, user):
      roles, joueurs = instance_data(reaction)
      # Le joueur est-il s√©l√©ctionn√© ?
      if user.mention in joueurs:
          # On le supprime de la liste des joueurs en le remplacant par libre
          for i, r in enumerate(roles):
              if joueurs[i] == user.mention and r==reaction.emoji:
                  joueurs[i] = 'libre'
                  break

          for i, r in enumerate(roles):
              if joueurs[i] == 'libre':
                  disponibles = [d for d in reaction.message.reactions if d.emoji == r][-1]
                  # On r√©cup√©re les utilisateurs en prennat soint de filtrer le bot
                  disponibles = [u for u in await disponibles.users().flatten() if u != bot.user and u.mention not in joueurs]
                  if disponibles:
                      joueurs[i] = disponibles[0].mention

      await update_instance_embed(reaction, roles, joueurs)

#+end_src

** Gestion des changement d'√©tat vocaux
(aka quand un user change de channel vocal)

#+name: on_voice_state_update
#+begin_src python
  @bot.event
  async def on_voice_state_update(member, before, after):
      if before.channel and before.channel.category_id == 948167052722573322:
          if not before.channel.members:
              await before.channel.delete()

#+end_src
