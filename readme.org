#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+TITLE: Invabot

* Documentation des rôles
#+begin_export html
<script async src="https://nwdb.info/embed.js"></script>
#+end_export
Cette section a pour objectif de présenter les différents rôles utiles
en invasion. Chaque rôle comporte des composantes indispensables,
illustrées par le sigle suivant : /(obligatoire)/. Afin de mieux
maîtriser la répartition des rôles, il sera demandé aux joueurs
d'évaluer leur pertinence pour chacun de ces rôles.

Un joueur peut s'estimer :

- Capable :: S'il répond à tous les critères tagués */(obligatoire)/*
- Opti :: S'il répond a tous les critères tagués */(obligatoire)/* *ET* */(recommandé)/*.

** Arc
- *Objectif* :: DPS les *têtes*, les *boss*, les engins de sièges et
  AoE les trashs, dans cet ordre de priorité.
- *Arme principale* :: Arc 580 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] */(obligatoire)/* et [[https://nwdb.info/db/perk/perkid_weapon_empoweroncrit][Keenly
  Empowered]] */(recommandé)/*. [[https://nwdb.info/build?skills=4-iw75uo-ngewxw][Build arc]] */(recommandé)/*
- *Arme secondaire* :: Arme débuff distance comme la hachette ou la lance avec [[https://nwdb.info/db/perk/perkid_ability_spear_javelin][Sundering Javelin]] sur pièce d'armure */(recommandé)/*
- *Armure et perks* :: Légère avec perks pour l'arc[[https://nwdb.info/db/perk/perkid_ability_bow_poisonshot][ Enfeebling Poison Shot]] et [[https://nwdb.info/db/perk/perkid_ability_bow_rapidshot][Penetrating Rapid Shot]] */(recommandé)/*
[[https://nwdb.info/db/perk/perkid_ability_spear_javelin][      Sundering Javelin]] */(recommandé si lance en secondaire)/*

** Mousquet

- *Objectif* :: DPS les *têtes* et les *boss*, dans cet ordre de priorité.
- *Arme principale* :: Mousquet 570 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] */(obligatoire)/* et
  [[https://nwdb.info/db/perk/perkid_weapon_dmgbasic][Enchanted]] */(recommandé)/*  [[https://nwdb.info/build?skills=6-nm5y04-qtbfgg][Build Mousquet]] */(recommandé)/*
- *Armure et perks* :: Légère avec perks pour le mousquet [[https://nwdb.info/db/perk/perkid_ability_musket_shootersstance][Empowering Shooter's
  Stance]] */(recommandé)/*.

** Anti-Trash

- *Objectif* :: Empêcher les *trash-mobs* d'atteindre les autres joueurs et les portes.
- *Arme principale* :: Hache double 580 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] */(obligatoire)/*
  [[https://nwdb.info/db/item/sapphirecutt4][Pristine Sapphire]] */(obligatoire)/* et [[https://nwdb.info/db/item/sapphirecutt4 [[https://nwdb.info/db/perk/perkid_weapon_empoweroncrit][Keenly Empowered]] (recommandé).
  [[https://nwdb.info/build?skills=8-j1mxog-kc3hhg][Build Hache double]] */(obligatoire)/*
- *Arme secondaire* :: Arme CàC, Marteau pour le contrôle ?
- *Armure et perks* :: Lourde */(recommandé)/* [[https://nwdb.info/db/perk/perkid_ability_greataxe_gravitywell][Insatiable Gravity Well]]
  */(obligatoire)*/ [[https://nwdb.info/db/perk/perkid_ability_greataxe_maelstrom][Enfeebling Maelstrom]] et [[https://nwdb.info/db/perk/perkid_ability_greataxe_whirlwind][Fortifying Whirlwind]]
  */(recommandé)/* et pour de la survivabilité [[https://nwdb.info/db/perk/perkid_armor_defcorrupted][Corrupted Ward]] sur
  quelques pièces */(recommandé)/*

** DPS debuff

- *Objectif* :: Appliquer */rend/* et */weaken/* aux boss et les DPS
- *Arme principale* :: Lance 580 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] */(obligatoire)/* et
  [[https://nwdb.info/db/perk/perkid_weapon_empoweroncrit][Keenly Empowered]] ou [[https://nwdb.info/db/perk/perkid_weaponmelee_dmgback][Rogue]] */(recommandé)/*. [[https://nwdb.info/build?skills=10-l71p4w-tsmm2s][Build lance]]
  */(obligatoire)/*
- *Arme secondaire* :: Arc préféré, mais peut être une arme de CàC.
- *Armure* :: Légère avec perks [[https://nwdb.info/db/perk/perkid_ability_spear_javelin][Sundering Javelin]] */(obligatoire)/*
  [[https://nwdb.info/db/perk/perkid_ability_spear_skewer][Enfeebling Skewer]] */(obligatoire)/* [[https://nwdb.info/db/perk/perkid_ability_spear_perforate][Fortifying Perforate]] */(recommandé)/*
  et pour de la survivabilité [[https://nwdb.info/db/perk/perkid_armor_defcorrupted][Corrupted Ward]] sur quelques pièces */(recommandé)/*

** Pustule boy
- *Objectif* :: Tirer en *priorité sur les pustules* qui se forment
  lors de l'impact d'un bison à l'intérieur du fort. Aider au centre.

- *Arme principale* :: Arme distante */(obligatoire)/*, les armes
  Néant/Arc/Feu */(recommandé)/* sont plus efficaces dans ce rôle
  grâce à une meilleure cadence de tir.
- *Arme secondaire* ::  Arc/Mousquet */(recommandé)/*

** Réparateur
- *Objectif* :: Gérer les ressources et *réparer les portes*.
- *Arme principale* :: Hachette avec [[https://nwdb.info/db/ability/ult_passive_hatchet_immortalwhen0hp][Defy Death]] */(recommandé)/*
- *Arme secondaire* :: Arme avec mobilité */(recommandé)/*

PS: Si vous n'avez jamais joué Hachette, il suffit de débloquer 12
points de compétence. C'est assez rapide et vous n'avez pas besoin
d'une arme haut niveau/particulière.

** Artilleur

- *Objectif* :: Tuer les bombers, les tireurs, les artilleries
  ennemies et les trash mob, en respectant cet ordre de priorité.

- *Arme principale* :: Épée avec la compétence [[https://nwdb.info/db/ability/ultimate_sword_swordmaster][Leadership]] */(obligatoire)/*
- *Arme secondaire* :: Bâton de feu/vie/hachette */(recommandé)/*

PS: Si vous n'avez jamais joué l'épée, il suffit de débloquer 12
points de compétence. C'est assez rapide et vous n'avez pas besoin
d'une arme haut niveau/particulière.
** Heal
- *Objectif* :: Maintenir l'équipe *Anti-trash* en vie en priorité
  puis empêcher les *trash-mobs* d'atteindre les autres joueurs et les
  portes.
- *Arme principale* :: Bâton de vie 580 GS min */(obligatoire)/* avec [[https://nwdb.info/db/perk/perkid_weaponlife_healoutgoing][Blessed]]
  */(recommandé)/*
- *Arme secondaire* :: Hache double avec [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] et [[https://nwdb.info/db/item/ambercutt4][Pristine
  Amber]] */(recommandé)/* [[https://nwdb.info/build?skills=8-j1mxog-kc3hhg][Build Hache double]] */(recommandé)/*

  OU

  Gantelet du néant

- *Armure* :: [[https://nwdb.info/db/perk/perkid_armor_defcorrupted][Corrupted Ward]] sur quelques pièces */(recommandé)/*


** Mage AOE

- *Objectif* :: DPS les *boss* dans les phases de fin, quand ils
  s'accumulent sur les portes.
- *Arme principale* :: Bâton de feu 580 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] avec [[https://nwdb.info/db/item/sapphirecutt4][Pristine Sapphire]] */(obligatoire)/*
  et [[https://nwdb.info/db/perk/perkid_weapon_empoweroncrit][Keenly Empowered]] */(recommandé)/*.
- *Arme secondaire possible* :: Mousquet [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] et [[https://nwdb.info/db/perk/perkid_weapon_dmgbasic][Enchanted]] avec
  [[https://nwdb.info/db/item/sapphirecutt4][Pristine Sapphire]] */(recommandé)/*
  OU
  Gantelet de glace pour bloquer les boss
- *Armure* :: Légère


* Damage formula


* Bot Discord
** Concept :

 Le bot à pour objectif de générer une composition d'armée à partir des
 50 joueurs sélectionnés aléatoirement par le jeu.

** Configuration

 La configuration du bot passera par un fichier json unique, contenant
 le corps des différents messages à transmettre ainsi que les adresses
 des Gdoc à lire.
 #+begin_src json :tangle config.json
   {
   "ids": {
       "role": 917546013248606238,
       "leads": 928316217297612810
   },
   "doc":{
       "Arc": "https://virgile-dauge.github.io/invabot/#org8c491a8",
       "Mousquet": "https://virgile-dauge.github.io/invabot/#orgb231e28",
       "Anti-Trash": "https://virgile-dauge.github.io/invabot/#org225c284",
       "DPS-Debuff": "https://virgile-dauge.github.io/invabot/#org278d923",
       "Pustule Boy": "https://virgile-dauge.github.io/invabot/#orgc63d37d",
       "Réparateur": "https://virgile-dauge.github.io/invabot/#org070ef35",
       "Artilleur": "https://virgile-dauge.github.io/invabot/#orgea113af",
       "Heal": "https://virgile-dauge.github.io/invabot/#org76b2a6b",
       "Mage AOE": "https://virgile-dauge.github.io/invabot/#orgc3f8667"
   },
   "imgs": {
       "layout": "https://cdn.discordapp.com/attachments/917547596640296990/922901028519706674/layout.png"
   },
   "embeds": {
       "panneau": {
           "title": "Confirme ta séléction à l'invasion de",
           "color": 2003199,
           "description": "Réagis avec :ballot_box_with_check: à ce message **uniquement si tu es déjà dans le fort**. Attention, retourne vite en jeu, l'auto-AFK kick est rapide (2min). \n\n Si tu as réagi par erreur, merci de décocher ta réaction. :wink: \n\n*(Et si vous aussi vous pensez que bakhu est la meilleure guilde)*"
       },
       "dm": {
           "title": "Dis nous tout !",
           "color": 2003199,
           "description": "Tu es inscrit en invasion, mais tu n'as pas renseigné **les rôles** que tu peux jouer. Il n'est donc par conséquent pas possible de t'assigner un poste automatiquement. Allez, file remplir [ce document]("
       },
       "change": {
           "title": "Tu as changé ton discord TAG :/",
           "color": 2003199,
           "description": "Il faut mettre à jour tes infos. Allez, file remplir [ce document]("
       },
       "help": {
           "title": "Manuel d'utilisation d'invabot",
           "color": 2003199,
           "fields": [{"name": "Blue Team", "value": "Something", "inline" : "True"}]
       }
   },
   "gdoc": {
       "url": "https://docs.google.com/spreadsheets/d/1FgtMvUQbLxP7qvXt2tnVwFFyX9KWnuREHu7o0RtX13M/",
       "page_strat": "Strat_principale",
       "page_roster": "Roster",
       "form": "https://forms.gle/G9LizybajjVxCw6JA"
   }
   }
 #+end_src



** Utilitaires
*** Dépendances
#+begin_src python :tangle bot.py

   import pandas as pd
   from algo import build_comp

   import discord
   from discord.ext import commands
#+end_src
*** Chargement de la config

 Le chargement de cette config se fera pour l'instant une seule fois au
 démarrage du bot.

 #+begin_src python :tangle bot.py
   # Chargement de la config du bot
   import json
   with open('config.json', 'r') as datafile:
       config = json.load(datafile)
 #+end_src

*** Chargement du token
 #+begin_src python :tangle bot.py
   # Chargement du token
   with open('bot.token', 'r') as datafile:
       token = datafile.read()
 #+end_src
*** Identifiant

 Il est nécessaire d'avoir un identifiant unique entre discord et le
 gdoc pour faire le lien. Discord gère les identifiants sous forme d'un
 entier appelé /snowflake/. Toutefois, il est difficilement accessible
 pour les joueurs, et ce sont les joueurs qui vont devoir renseigner
 leur identifiant unique sur le gdoc. Il est donc plus simple
 d'utiliser ici le *discord tag*, par exemple `Virgile#1234`.

 Je propose ici une rapide fonction d'aide pour récupérer le dtag
 depuis un objet /discord.User/ :
 #+begin_src python :tangle bot.py
   def dtag(user):
       return f'{user.name}#{user.discriminator}'
 #+end_src

*** Récupération du roster

 #+begin_src python :tangle bot.py
   import pandas as pd
   def get_roster(config):
       url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={config['gdoc']['page_roster']}"
       #return pd.read_csv(url).iloc[1:, 0:6].dropna().set_index('dtag')
       return pd.read_csv(url).set_index('dtag')
 #+end_src

 #+begin_example
                 Pseudo             0           1     2           3
 dtag
 Chopekk#1234   Chopekk    DPS-Debuff    Mousquet  Heal  Anti-trash
 Virgile#2345  virgilio      Mousquet  Anti-trash  Répa        Arti
 Virgile#3456     Tezig  Lance-flamme  Anti-trash   Arc        Arti
 Carlito#4567      Slua    Anti-trash        Arti  Répa       Aucun
 #+end_example
*** Récupération de la strat

 #+begin_src python :tangle bot.py
   def get_strat(config):
       url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={config['gdoc']['page_strat']}"
       return pd.read_csv(url).iloc[0:5, 0:12]
 #+end_src

 #+begin_example
      Groupe 1 Groupe 2    Groupe 3 Groupe 4    Groupe 5    Groupe 6    Groupe 7    Groupe 8 Groupe 9     Groupe 10
 0  Anti-Trash      Arc  Anti-Trash      Arc  Anti-Trash    Mousquet  Anti-Trash    Mousquet     Répa  Lance-flamme
 1        Heal      Arc        Heal      Arc        Heal    Mousquet        Heal    Mousquet     Répa  Lance-flamme
 2  DPS-Debuff      Arc  DPS-Debuff      Arc  DPS-Debuff    Mousquet  DPS-Debuff    Mousquet     Répa  Lance-flamme
 3  DPS-Debuff      Arc  DPS-Debuff      Arc  DPS-Debuff  DPS-Debuff  DPS-Debuff  DPS-Debuff     Répa  Lance-flamme
 4        Arti     Arti        Arti     Arti        Arti        Arti        Arti        Arti     Répa  Lance-flamme
 #+end_example

** Bot avec discord.py
 https://discordpy.readthedocs.io/en/stable/

 Création du bot
 #+begin_src python :tangle bot.py :noweb yes

   intents = discord.Intents.default()
   intents.reactions = True
   intents.members = True
   bot = commands.Bot(command_prefix="!", intents=intents)

   msgs = {}
   msgs_ids = []

   @bot.event
   async def on_ready():
       print('We have logged in as {0.user}'.format(bot))
       game = discord.Game("Venez chez Bakhu")
       await bot.change_presence(status=discord.Status.online, activity=game)

   <<rm_cmd>>
 #+end_src
*** Clear
#+name: clear
#+begin_src python :tangle bot.py
   @bot.command()
   async def clear(ctx, opt='me'):
       #global hist
       #await rm_cmd(ctx)
       if opt == 'me':
           deleted = await ctx.channel.purge(check=lambda msg: msg.author == ctx.author)
           await ctx.channel.send('Deleted {} message(s)'.format(len(deleted)), delete_after=2)
           #print(hist[ctx.author])
       elif opt == 'all':
           guild = ctx.guild
           lead_role = guild.get_role(config["ids"]["leads"])

           if ctx.author not in lead_role.members:
               embed = discord.Embed(title='Droits insuffisants')
               embed.color = 16748319
               embed.description = f'Rôle ***{lead_role}*** requis'
               await ctx.channel.send(embed=embed, delete_after=10)
               return

           await ctx.channel.purge()
           global msgs
           msgs = {}
           global msgs_ids
           msgs_ids = []
 #+end_src

#+name: rm_cmd
#+begin_src python :tangle no
    async def rm_cmd(ctx):
      try:
          await ctx.message.delete()
      except Exception as e:
          print(e)
 #+end_src

#+name: add_to_hist
#+begin_src python :tangle no
  def add_to_hist(author, mid):
    global hist
    if author in hist and hist[author]:
       hist[author] += [mid]
    else:
       hist[author] = [mid]
 #+end_src

*** Inva
 Commande d'ajout du panneau d'inscription, sur lequel les joueurs dans
 le fort doivent se signaler sera `!inva nomVille`
 #+begin_src python :tangle bot.py
   @bot.command()
   async def inva(ctx, arg="NomVille"):
       """ Génére un tableau d'inscription dans le channel
       """
       # Suppression du message d'invocation
       await rm_cmd(ctx)

       embed = discord.Embed.from_dict(config["embeds"]["panneau"])
       embed.title += f' {arg}'
       embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)

       msg = await ctx.channel.send(embed=embed, delete_after=60*20)
       await msg.add_reaction('☑')

       #add_to_hist(ctx.author, msg.id)

       author_id = dtag(ctx.author)
       msgs[author_id] = msg.id
       global msgs_ids
       msgs_ids += [msg.id]
       #add_to_hist(ctx.author, msg.id)

 #+end_src
*** Composition d'armée

 La commande de demande de *composition* sera la suivante `!comp`. La
 fonction associée doit récupérer le message /panneau/ à partir de
 l'identité de l'appelant. Puis, récupérer la liste des joueurs qui ont
 réagi sur le panneau.
 #+begin_src python :tangle bot.py :noweb yes
   @bot.command()
   async def comp(ctx):
       """ Génére une composition d'armée
       """
       # Suppression du message d'invocation
       await rm_cmd(ctx)

       author_dtag = dtag(ctx.author)
       channel = ctx.channel

       # On s'assure que l'utilisateur qui demande le calcul ait déjà fait la commande principale
       if author_dtag not in msgs:
           embed = discord.Embed(title='Pas de tableau correspondant...')
           embed.color = 16748319
           embed.description = f'Laissez le lead calculer la composition ! \n\nSi vous êtes lead, commencez par utiliser la commande : \n `!inva nomville`'
           await ctx.channel.send(embed=embed, delete_after=10)
           return

       # Récupération du message avec les réacs
       msg_id = msgs[author_dtag]
       main_msg = await channel.fetch_message(msg_id)

       # Récupération de la liste des users
       selected = await main_msg.reactions[0].users().flatten()
       selected_tags = [dtag(u) for u in selected][1:]
       selected_snow = {t: u.id for t, u in zip(selected_tags, selected)}

       # Récupération des donénes du Gdoc roster
       roster = get_roster(config)

       # Joueurs séléctionnés n'ayant pas rempli le Gdoc
       not_registered = [u for u in selected_tags if u not in roster.index]

       # Filtrage du roster avec les joueurs séléctionnés
       roster = roster.filter(items=selected_tags, axis=0).set_index('Pseudo IG')
       #print(roster)
       # Récupération de la strat
       strat = get_strat(config)
       comp = build_comp(roster, strat, config)
       <<gen_embed>>
       embed = gen_embed(comp)
       embed.title = f"Invasion de {main_msg.embeds[0].title.split(' ')[-1]}, composition :"
       embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)
       embed.color = 2003199
       embed.set_thumbnail(url=config['imgs']['layout'])
       await channel.send(embed=embed, delete_after=60*25)
       #add_to_hist(ctx.author, msg.id)

 #+end_src

#+name: gen_embed
#+begin_src python
  def gen_embed(comp):
     e = discord.Embed(title="Composition d'armée")
     for k, v in comp.iteritems():
         f = ''
         for p in v.to_list():
             f += p + '\n'
         e.add_field(name=k, value=f, inline=True)
     return e


#+end_src

*** Comptage des inscrits

 #+begin_src python :tangle bot.py :noweb yes
   @bot.command()
   async def cb(ctx):
       """ Compte les inscrits enregistrés
       """
       # Suppression du message d'invocation
       await rm_cmd(ctx)

       author_dtag = dtag(ctx.author)
       channel = ctx.channel

       # On s'assure que l'utilisateur qui demande le calcul ait déjà fait la commande principale
       if author_dtag not in msgs:
           embed = discord.Embed(title='Pas de tableau correspondant...')
           embed.color = 16748319
           embed.description = f'Laissez le lead calculer la composition ! \n\nSi vous êtes lead, commencez par utiliser la commande : \n `!inva nomville`'
           await ctx.channel.send(embed=embed, delete_after=2)
           return

       # Récupération du message avec les réacs
       msg_id = msgs[author_dtag]
       main_msg = await channel.fetch_message(msg_id)
       #print(main_msg.embeds[0].title.split(' ')[-1])
       # Récupération de la liste des users
       selected = await main_msg.reactions[0].users().flatten()
       selected_tags = [dtag(u) for u in selected][1:]

       # Récupération des donénes du Gdoc roster
       roster = get_roster(config)

       # Joueurs séléctionnés n'ayant pas rempli le Gdoc
       not_registered = [u for u in selected_tags if u not in roster.index]

       # Filtrage du roster avec les joueurs séléctionnés
       roster = roster.filter(items=selected_tags, axis=0).set_index('Pseudo IG')

       embed = discord.Embed(title=f"Invasion de {main_msg.embeds[0].title.split(' ')[-1]}, **{len(roster)}** enregistrés.")
       embed.color = 2003199
       embed.description = f"S'il y a tout le monde, le lead peut utiliser :\n\n `!comp`"
       embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)
       await ctx.channel.send(embed=embed, delete_after=2)
 #+end_src
*** DM des joueurs qui n'ont pas renseigné leurs rôles

 Cette phase n'est pas absolument nécessaire, mais elle permet de
 notifier directement en message privé les utilisateurs qui se
 signalent dans le fort mais qui n'ont pas correctement rempli le
 gdoc. Cela leur laisse potentiellement le temps de le faire avant que
 le lead demande le calcul de la composition du groupement de défense.
 #+begin_src python :tangle bot.py
   @bot.event
   async def on_reaction_add(reaction, user):
        # On vérifie que la réaction est sur un message panneau
        if reaction.message.id not in msgs_ids:
            return
        if user == bot.user:
            return

        # Récupération des donénes du Gdoc roster
        df = get_roster(config)
        if dtag(user) not in df.index:
            embed = discord.Embed.from_dict(config["embeds"]["dm"])
            embed.description += f'{config["gdoc"]["form"]}) ***!***'
            try:
                await user.send(embed=embed)
            except discord.errors.HTTPException as e:
                pass
        else:
            guild = reaction.message.guild
            role = guild.get_role(config["ids"]["role"])
            if role is None:
                # Make sure the role still exists and is valid.
                return

            try:
                # Finally, add the role.
                await user.add_roles(role)
            except discord.HTTPException:
                # If we want to do something in case of errors we'd do it here.
                pass

 #+end_src

*** Vérification des enregistrés
 #+begin_src python :tangle bot.py
   @bot.command()
   async def verif(ctx):
       """ Attribue les rôles
       """
       print(f'!verif command invoked by {dtag(ctx.author)}')
       # Suppression du message d'invocation
       await rm_cmd(ctx)

       guild = ctx.guild
       lead_role = guild.get_role(config["ids"]["leads"])

       if ctx.author not in lead_role.members:
           embed = discord.Embed(title='Droits insuffisants')
           embed.color = 16748319
           embed.description = f'Rôle ***{lead_role}*** requis'
           await ctx.channel.send(embed=embed, delete_after=2)
           return
       # Récupération des donénes du Gdoc roster
       roster_df = get_roster(config)
       roster = list(roster_df.index)


       members = {dtag(m): m for m in guild.members}

       role = guild.get_role(config["ids"]["role"])
       verified = [dtag(m) for m in role.members]

       added = []
       wrong = []
       for u in roster:
          if u not in members:
              wrong += [u]
          elif u not in verified:
              if role is None:
                  # Make sure the role still exists and is valid.
                  return

              try:
                  # Finally, add the role.
                  await members[u].add_roles(role)
                  added += [u]
              except discord.HTTPException:
                  # If we want to do something in case of errors we'd do it here.
                  pass

       removed = []
       for u in verified:
           if u not in roster:
               try:
                   # Finally, remove the role.
                   await members[u].remove_roles(role)
                   removed += [u]

                   # Send DM to user
                   embed = discord.Embed.from_dict(config["embeds"]["change"])
                   embed.description += f'{config["gdoc"]["form"]}) ***!***'
                   await members[u].send(embed=embed)
               except discord.HTTPException:
                   # If we want to do something in case of errors we'd do it here.
                   pass

       def list_to_field(l):
           f = 'aucun'
           if l:
               f = ''
               for u in l:
                   f += u + '\n'
           if len(f)>1023:
               return f[:1000]+'...'
           return f

       def add_IG(l, roster_df):
           return [f"{i} | {roster_df.loc[i]['Pseudo IG']}" for i in l]
       wrong = add_IG(wrong, roster_df)
       added = add_IG(added, roster_df)
       embed = discord.Embed()
       embed.title = f'Vérification du gdoc'
       embed.color = 2003199
       embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)

       embed.add_field(name="Joueurs nouvellement vérifiés", value=list_to_field(added), inline=False)
       embed.add_field(name="Discord tag dans le Gdoc ne correspondant à aucun membre du discord", value=list_to_field(wrong), inline=False)
       embed.add_field(name=f"Joueurs ayant changé de Discord tag (rôle {role} supprimé)", value=list_to_field(removed), inline=False)
       await ctx.channel.send(embed=embed, delete_after=20*60)
       #print(added, wrong)


 #+end_src
*** Run

 #+begin_src python :tangle bot.py
 bot.run(token)
 #+end_src

* Algo
Dépendances
#+begin_src python :tangle algo.py
import numpy as np
import pandas as pd
from scipy.optimize import linear_sum_assignment
#+end_src

Récupération du roster de test
 #+begin_src python :tangle algo.py
   def get_test_roster():
       page= 'Roster'
       url = f"https://docs.google.com/spreadsheets/d/1FgtMvUQbLxP7qvXt2tnVwFFyX9KWnuREHu7o0RtX13M/gviz/tq?tqx=out:csv&sheet={page}"
       #return pd.read_csv(url).iloc[:, 0:16].dropna().set_index('dtag')
       return pd.read_csv(url).set_index('dtag')
 #+end_src

#+begin_src python :tangle algo.py
    def get_test_strat():
      page= 'Strat'
      url = f"https://docs.google.com/spreadsheets/d/1vDZ_p6Bq2oyyY0CV1SQ0FBRtJoGbtiurM9cOQWHJ-qo/gviz/tq?tqx=out:csv&sheet={page}"
      return pd.read_csv(url).iloc[0:5, 0:12]
#+end_src

 Identification des Rôles :
 #+begin_src python :tangle algo.py :noweb yes

   def build_comp(roster, strat, config):
       roles = {}
       for index, row in strat.iterrows():
           for v in row:
               if v in roles:
                   roles[v] += 1
               else:
                   roles[v] = 1

       max_roles = {k: v.max() for k,v in roster.iteritems()}
       <<cout>>
       <<res>>
       <<comp>>
 #+end_src

Création des colonnes avec les noms de rôles, les lignes avec les noms
de joueurs, et de la matrice de coûts.
 #+name: cout
 #+begin_src python

   cols = [k for k, v in roles.items() for _ in range(v)]
   rows = roster.index

   C = np.zeros((len(rows), len(cols)), dtype=int)

   for i, r in enumerate(rows):
       for j, c in enumerate(cols):
           C[i, j] = roster.at[r, c]
 #+end_src


Résolution du problème d'affectation avec la maximisation suivante :
$$max \sum_{i} \sum_{j} C_{i,j} X_{i,j}$$
#+name: res
#+begin_src python

row_ind, X = linear_sum_assignment(C, maximize=True)
score = C[row_ind, X].sum()
assignent = {p: cols[t] for p, t in zip(rows, X)}

#+end_src

Analyse des résultats
#+begin_src python :tangle no
  for k, v in assignent.items():
      print(k, v, roster.at[k, v])

#+end_src

Remplissage du tableau
#+name: comp
#+begin_src python
  filed_roles = {}
  for k, v in assignent.items():
      #print(k, v)
      if v not in filed_roles:
          filed_roles[v] = [k]
      else:
          filed_roles[v] += [k]

  comp = strat.copy()
  for i, row in comp.iterrows():
      for j, v in row.items():
          if v in filed_roles and filed_roles[v]:
              p = filed_roles[v].pop()
              role_txt = comp.at[i, j]
              if role_txt in config['doc']:
                  role_txt = f"[{role_txt}]({config['doc'][role_txt]})"
              comp.at[i, j] = f'**{p}** *{role_txt}* {roster.at[p, v] / max_roles[v]:.1f}'
  return comp
#+end_src

** Test algo

#+begin_src python :tangle algo.py

  if __name__ == '__main__':
      roster = get_test_roster().set_index('Pseudo IG')
      roster.to_csv('roster.csv')
      print(roster)
      strat = get_test_strat()
      strat.to_csv('strat.csv')
      print(strat)
      print(build_comp(roster, strat))
#+end_src
**** Filtrage des joueurs
 #+begin_src python :tangle no
 keys_to_extract = []
 a_subset = {key: players[key] for key in keys_to_extract}
 #+end_src
