#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+TITLE: Invabot

* Documentation des rôles
#+begin_export html
<script async src="https://nwdb.info/embed.js"></script>
#+end_export
Cette section a pour objectif de présenter les différents rôles utiles
en invasion. Chaque rôle comporte des composantes indispensables,
illustrées par le sigle suivant : /(obligatoire)/. Afin de mieux
maîtriser la répartition des rôles, il sera demandé aux joueurs
d'évaluer leur pertinence pour chacun de ces rôles.

Un joueur peut s'estimer :

- Capable :: S'il répond à tous les critères tagués */(obligatoire)/*
- Opti :: S'il répond a tous les critères tagués */(obligatoire)/* *ET* */(recommandé)/*.

** Arc
- *Objectif* :: DPS les *têtes*, les *boss*, les engins de sièges et
  AoE les trashs, dans cet ordre de priorité.
- *Arme principale* :: Arc 580 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] */(obligatoire)/* et [[https://nwdb.info/db/perk/perkid_weapon_empoweroncrit][Keenly
  Empowered]] */(recommandé)/*. [[https://nwdb.info/build?skills=4-iw75uo-ngewxw][Build arc]] */(recommandé)/*
- *Arme secondaire* :: Arme débuff distance comme la hachette ou la lance avec [[https://nwdb.info/db/perk/perkid_ability_spear_javelin][Sundering Javelin]] sur pièce d'armure */(recommandé)/*
- *Armure et perks* :: Légère avec perks pour l'arc[[https://nwdb.info/db/perk/perkid_ability_bow_poisonshot][ Enfeebling Poison Shot]] et [[https://nwdb.info/db/perk/perkid_ability_bow_rapidshot][Penetrating Rapid Shot]] */(recommandé)/*
[[https://nwdb.info/db/perk/perkid_ability_spear_javelin][      Sundering Javelin]] */(recommandé si lance en secondaire)/*

** Mousquet

- *Objectif* :: DPS les *têtes* et les *boss*, dans cet ordre de priorité.
- *Arme principale* :: Mousquet 570 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] */(obligatoire)/* et
  [[https://nwdb.info/db/perk/perkid_weapon_dmgbasic][Enchanted]] */(recommandé)/*  [[https://nwdb.info/build?skills=6-nm5y04-qtbfgg][Build Mousquet]] */(recommandé)/*
- *Armure et perks* :: Légère avec perks pour le mousquet [[https://nwdb.info/db/perk/perkid_ability_musket_shootersstance][Empowering Shooter's
  Stance]] */(recommandé)/*.

** Anti-Trash

- *Objectif* :: Empêcher les *trash-mobs* d'atteindre les autres joueurs et les portes.
- *Arme principale* :: Hache double 580 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] */(obligatoire)/*
  [[https://nwdb.info/db/item/sapphirecutt4][Pristine Sapphire]] */(obligatoire)/* et [[https://nwdb.info/db/item/sapphirecutt4 [[https://nwdb.info/db/perk/perkid_weapon_empoweroncrit][Keenly Empowered]] (recommandé).
  [[https://nwdb.info/build?skills=8-j1mxog-kc3hhg][Build Hache double]] */(obligatoire)/*
- *Arme secondaire* :: Arme CàC, Marteau pour le contrôle ?
- *Armure et perks* :: Lourde */(recommandé)/* [[https://nwdb.info/db/perk/perkid_ability_greataxe_gravitywell][Insatiable Gravity Well]]
  */(obligatoire)*/ [[https://nwdb.info/db/perk/perkid_ability_greataxe_maelstrom][Enfeebling Maelstrom]] et [[https://nwdb.info/db/perk/perkid_ability_greataxe_whirlwind][Fortifying Whirlwind]]
  */(recommandé)/* et pour de la survivabilité [[https://nwdb.info/db/perk/perkid_armor_defcorrupted][Corrupted Ward]] sur
  quelques pièces */(recommandé)/*

** DPS debuff

- *Objectif* :: Appliquer */rend/* et */weaken/* aux boss et les DPS
- *Arme principale* :: Lance 580 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] */(obligatoire)/* et
  [[https://nwdb.info/db/perk/perkid_weapon_empoweroncrit][Keenly Empowered]] ou [[https://nwdb.info/db/perk/perkid_weaponmelee_dmgback][Rogue]] */(recommandé)/*. [[https://nwdb.info/build?skills=10-l71p4w-tsmm2s][Build lance]]
  */(obligatoire)/*
- *Arme secondaire* :: Arc préféré, mais peut être une arme de CàC.
- *Armure* :: Légère avec perks [[https://nwdb.info/db/perk/perkid_ability_spear_javelin][Sundering Javelin]] */(obligatoire)/*
  [[https://nwdb.info/db/perk/perkid_ability_spear_skewer][Enfeebling Skewer]] */(obligatoire)/* [[https://nwdb.info/db/perk/perkid_ability_spear_perforate][Fortifying Perforate]] */(recommandé)/*
  et pour de la survivabilité [[https://nwdb.info/db/perk/perkid_armor_defcorrupted][Corrupted Ward]] sur quelques pièces */(recommandé)/*

** Pustule boy
- *Objectif* :: Tirer en *priorité sur les pustules* qui se forment
  lors de l'impact d'un bison à l'intérieur du fort. Aider au centre.

- *Arme principale* :: Arme distante */(obligatoire)/*, les armes
  Néant/Arc/Feu */(recommandé)/* sont plus efficaces dans ce rôle
  grâce à une meilleure cadence de tir.
- *Arme secondaire* ::  Arc/Mousquet */(recommandé)/*

** Réparateur
- *Objectif* :: Gérer les ressources et *réparer les portes*.
- *Arme principale* :: Hachette avec [[https://nwdb.info/db/ability/ult_passive_hatchet_immortalwhen0hp][Defy Death]] */(recommandé)/*
- *Arme secondaire* :: Arme avec mobilité */(recommandé)/*

PS: Si vous n'avez jamais joué Hachette, il suffit de débloquer 12
points de compétence. C'est assez rapide et vous n'avez pas besoin
d'une arme haut niveau/particulière.

** Artilleur

- *Objectif* :: Tuer les bombers, les tireurs, les artilleries
  ennemies et les trash mob, en respectant cet ordre de priorité.

- *Arme principale* :: Épée avec la compétence [[https://nwdb.info/db/ability/ultimate_sword_swordmaster][Leadership]] */(obligatoire)/*
- *Arme secondaire* :: Bâton de feu/vie/hachette */(recommandé)/*

PS: Si vous n'avez jamais joué l'épée, il suffit de débloquer 12
points de compétence. C'est assez rapide et vous n'avez pas besoin
d'une arme haut niveau/particulière.
** Heal
- *Objectif* :: Maintenir l'équipe *Anti-trash* en vie en priorité
  puis empêcher les *trash-mobs* d'atteindre les autres joueurs et les
  portes.
- *Arme principale* :: Bâton de vie 580 GS min */(obligatoire)/* avec [[https://nwdb.info/db/perk/perkid_weaponlife_healoutgoing][Blessed]]
  */(recommandé)/*
- *Arme secondaire* :: Hache double avec [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] et [[https://nwdb.info/db/item/ambercutt4][Pristine
  Amber]] */(recommandé)/* [[https://nwdb.info/build?skills=8-j1mxog-kc3hhg][Build Hache double]] */(recommandé)/*

  OU

  Gantelet du néant

- *Armure* :: [[https://nwdb.info/db/perk/perkid_armor_defcorrupted][Corrupted Ward]] sur quelques pièces */(recommandé)/*


** Mage AOE

- *Objectif* :: DPS les *boss* dans les phases de fin, quand ils
  s'accumulent sur les portes.
- *Arme principale* :: Bâton de feu 580 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] avec [[https://nwdb.info/db/item/sapphirecutt4][Pristine Sapphire]] */(obligatoire)/*
  et [[https://nwdb.info/db/perk/perkid_weapon_empoweroncrit][Keenly Empowered]] */(recommandé)/*.
- *Arme secondaire possible* :: Mousquet [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] et [[https://nwdb.info/db/perk/perkid_weapon_dmgbasic][Enchanted]] avec
  [[https://nwdb.info/db/item/sapphirecutt4][Pristine Sapphire]] */(recommandé)/*
  OU
  Gantelet de glace pour bloquer les boss
- *Armure* :: Légère


* Bot
** Concept :

 Le bot à pour objectif de générer une composition d'armée à partir des
 50 joueurs sélectionnés aléatoirement par le jeu.

** Configuration

 La configuration du bot passera par un fichier json unique, contenant
 le corps des différents messages à transmettre ainsi que les adresses
 des Gdoc à lire.
 #+begin_src json :tangle config.json
   {
   "ids": {
       "role": 917546013248606238,
       "leads": 928316217297612810
   },
   "doc":{
       "url": "https://virgile-dauge.github.io/invabot/"
   },
   "imgs": {
       "layout": "https://cdn.discordapp.com/attachments/917547596640296990/922901028519706674/layout.png"
   },
   "embeds": {
       "panneau": {
           "title": "Confirme ta séléction à l'invasion de",
           "color": 2003199,
           "description": "Réagis avec :ballot_box_with_check: à ce message **uniquement si tu es déjà dans le fort**. Attention, retourne vite en jeu, l'auto-AFK kick est rapide (2min). \n\n Si tu as réagi par erreur, merci de décocher ta réaction. :wink: \n\n*(Et si vous aussi vous pensez que bakhu est la meilleure guilde)*"
       },
       "dm": {
           "title": "Dis nous tout !",
           "color": 2003199,
           "description": "Tu es inscrit en invasion, mais tu n'as pas renseigné **les rôles** que tu peux jouer. Il n'est donc par conséquent pas possible de t'assigner un poste automatiquement. Allez, file remplir [ce document]("
       },
       "change": {
           "title": "Tu as changé ton discord TAG :/",
           "color": 2003199,
           "description": "Il faut mettre à jour tes infos. Allez, file remplir [ce document]("
       },
       "help": {
           "title": "Manuel d'utilisation d'invabot",
           "color": 2003199,
           "fields": [{"name": "Blue Team", "value": "Something", "inline" : "True"}]
       }
   },
   "gdoc": {
       "url": "https://docs.google.com/spreadsheets/d/1FgtMvUQbLxP7qvXt2tnVwFFyX9KWnuREHu7o0RtX13M/",
       "strats": {
           "Principale": "Strat_principale",
           "Secours": "Strat_secours"
       },
       "page_roster": "Roster",
       "form": "https://forms.gle/G9LizybajjVxCw6JA"
   }
   }
 #+end_src



** Utilitaires
*** Dépendances
#+begin_src python :tangle bot.py

   import pandas as pd
   from algo import build_comp

#+end_src
*** Chargement de la config

 Le chargement de cette config se fera pour l'instant une seule fois au
 démarrage du bot.
#+name: config
 #+begin_src python :tangle bot.py
   # Chargement de la config du bot
   import json
   with open('config.json', 'r') as datafile:
       config = json.load(datafile)
 #+end_src

 #+begin_src python :tangle bot.py
   # Chargement de la config du bot
   import json
   with open('config.json', 'r') as datafile:
       config = json.load(datafile)
 #+end_src

*** Persistance

 Le chargement des données
#+name: data
 #+begin_src python
  # Chargement de la config du bot
  def load_data(path='data.json'):
      with open(path, 'r') as datafile:
          return json.load(datafile)
  def save_data(data, path='data.json'):
      with open(path, 'w') as datafile:
          json.dump(data, datafile, sort_keys=True, indent=4)
  def add_participation(participants):
      #print(participants)
      data = load_data()
      for p in participants:
          if p in data:
              data[p] +=1
          else:
              data[p] = 1
      #print(data)
      save_data(data)
 #+end_src
*** Chargement du token
#+Name: token
 #+begin_src python :tangle bot.py
   # Chargement du token
   with open('bot.token', 'r') as datafile:
       token = datafile.read()
 #+end_src
*** Identifiant

 Il est nécessaire d'avoir un identifiant unique entre discord et le
 gdoc pour faire le lien. Discord gère les identifiants sous forme d'un
 entier appelé /snowflake/. Toutefois, il est difficilement accessible
 pour les joueurs, et ce sont les joueurs qui vont devoir renseigner
 leur identifiant unique sur le gdoc. Il est donc plus simple
 d'utiliser ici le *discord tag*, par exemple `Virgile#1234`.

 Je propose ici une rapide fonction d'aide pour récupérer le dtag
 depuis un objet /discord.User/ :
 #+name: dtag
 #+begin_src python :tangle bot.py
   def dtag(user):
       return f'{user.name}#{user.discriminator}'
 #+end_src

*** Récupération du roster
#+name: get_roster
 #+begin_src python :tangle bot.py
   def get_roster(config):
       url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={config['gdoc']['page_roster']}"
       #return pd.read_csv(url).iloc[1:, 0:6].dropna().set_index('dtag')
       return pd.read_csv(url).set_index('dtag')
 #+end_src

 #+begin_example
                 Pseudo             0           1     2           3
 dtag
 Chopekk#1234   Chopekk    DPS-Debuff    Mousquet  Heal  Anti-trash
 Virgile#2345  virgilio      Mousquet  Anti-trash  Répa        Arti
 Virgile#3456     Tezig  Lance-flamme  Anti-trash   Arc        Arti
 Carlito#4567      Slua    Anti-trash        Arti  Répa       Aucun
 #+end_example
*** Récupération de la strat

 #+begin_src python :tangle bot.py
   def get_strat(config, strat=None):
       if strat is None:
           url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={config['gdoc']['page_strat']}"
       else:
           url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={config['gdoc']['page_strat']}"
       return pd.read_csv(url).iloc[0:5, 0:12]
 #+end_src

 #+begin_example
      Groupe 1 Groupe 2    Groupe 3 Groupe 4    Groupe 5    Groupe 6    Groupe 7    Groupe 8 Groupe 9     Groupe 10
 0  Anti-Trash      Arc  Anti-Trash      Arc  Anti-Trash    Mousquet  Anti-Trash    Mousquet     Répa  Lance-flamme
 1        Heal      Arc        Heal      Arc        Heal    Mousquet        Heal    Mousquet     Répa  Lance-flamme
 2  DPS-Debuff      Arc  DPS-Debuff      Arc  DPS-Debuff    Mousquet  DPS-Debuff    Mousquet     Répa  Lance-flamme
 3  DPS-Debuff      Arc  DPS-Debuff      Arc  DPS-Debuff  DPS-Debuff  DPS-Debuff  DPS-Debuff     Répa  Lance-flamme
 4        Arti     Arti        Arti     Arti        Arti        Arti        Arti        Arti     Répa  Lance-flamme
 #+end_example



* Algo
Dépendances
#+begin_src python :tangle algo.py
import numpy as np
import pandas as pd
from scipy.optimize import linear_sum_assignment
#+end_src

Récupération du roster de test
 #+begin_src python :tangle algo.py
   def get_test_roster():
       page= 'Roster'
       url = f"https://docs.google.com/spreadsheets/d/1FgtMvUQbLxP7qvXt2tnVwFFyX9KWnuREHu7o0RtX13M/gviz/tq?tqx=out:csv&sheet={page}"
       #return pd.read_csv(url).iloc[:, 0:16].dropna().set_index('dtag')
       return pd.read_csv(url).set_index('dtag')
 #+end_src

#+begin_src python :tangle algo.py
    def get_test_strat():
      page= 'Strat'
      url = f"https://docs.google.com/spreadsheets/d/1vDZ_p6Bq2oyyY0CV1SQ0FBRtJoGbtiurM9cOQWHJ-qo/gviz/tq?tqx=out:csv&sheet={page}"
      return pd.read_csv(url).iloc[0:5, 0:12]
#+end_src

#+RESULTS:
: None

 Identification des Rôles :
 #+begin_src python :tangle algo.py :noweb yes

   def build_comp(roster, strat, config):
       roles = {}
       for index, row in strat.iterrows():
           for v in row:
               v = v.split(' ')[0]
               if v in roles:
                   roles[v] += 1
               else:
                   roles[v] = 1

       max_roles = {k: v.max() for k,v in roster.iteritems()}
       <<cout>>
       <<res>>
       <<comp>>
 #+end_src

Création des colonnes avec les noms de rôles, les lignes avec les noms
de joueurs, et de la matrice de coûts.
 #+name: cout
 #+begin_src python

   cols = [k for k, v in roles.items() for _ in range(v)]
   rows = roster.index

   C = np.zeros((len(rows), len(cols)), dtype=int)

   for i, r in enumerate(rows):
       for j, c in enumerate(cols):
           C[i, j] = roster.at[r, c]
 #+end_src


Résolution du problème d'affectation avec la maximisation suivante :
$$max \sum_{i} \sum_{j} C_{i,j} X_{i,j}$$
#+name: res
#+begin_src python

row_ind, X = linear_sum_assignment(C, maximize=True)
score = C[row_ind, X].sum()
assignent = {p: cols[t] for p, t in zip(rows, X)}

#+end_src

Analyse des résultats
#+begin_src python :tangle no
  for k, v in assignent.items():
      print(k, v, roster.at[k, v])

#+end_src

Remplissage du tableau
#+name: comp
#+begin_src python
  filed_roles = {}
  for k, v in assignent.items():
      #print(k, v)
      if v not in filed_roles:
          filed_roles[v] = [k]
      else:
          filed_roles[v] += [k]

  comp = strat.copy()
  for i, row in comp.iterrows():
      for j, v in row.items():
          label = ''
          if len(v.split(' ')) > 1:
              v, label = v.split(' ')
          if v in filed_roles and filed_roles[v]:
              p = filed_roles[v].pop()
              role_txt = f"[{comp.at[i, j]}]({config['doc']['url']})"
              #if role_txt in config['doc']:
              #    role_txt = f"[{role_txt}]({config['doc'][url]})"
              comp.at[i, j] = f'{p} *{role_txt}* {roster.at[p, v] / max_roles[v]:.1f}'
  return comp
#+end_src

** Test algo

#+begin_src python :tangle algo.py

  if __name__ == '__main__':
      roster = get_test_roster().set_index('Pseudo IG')
      roster.to_csv('roster.csv')
      print(roster)
      strat = get_test_strat()
      strat.to_csv('strat.csv')
      print(strat)
      print(build_comp(roster, strat))
#+end_src
**** Filtrage des joueurs
 #+begin_src python :tangle no
 keys_to_extract = []
 a_subset = {key: players[key] for key in keys_to_extract}
 #+end_src


* TODO bot avec Disnake

** Corp
#+begin_src python :tangle bot.py :noweb tangle
  import pandas as pd
  from algo import build_comp

  import disnake
  from disnake.ext import commands
  from disnake import Embed, Emoji


  <<dtag>>
  <<get_roster>>
  <<config>>
  def list_to_field(l):
      f = 'aucun'
      if l:
          f = ''
          for u in l:
              f += u + '\n'
          if len(f)>1023:
              return f[:1000]+'...'
          return f

  def unique(l):
      u = []
      for r in l:
          if r not in u:
              u +=[r]
      return u

  def main():
      bot = commands.Bot(
          intents=disnake.Intents().all(),
          test_guilds=[906630964703289434], # Optional
          sync_commands_debug=True
      )
      <<data>>
      <<dis_transfert>>
      <<dis_inva_cmd>>
      <<dis_instance>>
      <<dis_verif>>
      <<check_user>>
      <<update_instance_add>>
      <<update_instance_rm>>
      <<on_reaction>>
      <<on_reaction_rm>>
      <<on_voice_state_update>>
      bot.run(token=open("bot.token").read()[:-1])

  if __name__ == "__main__":
      main()
#+end_src

** Commande inva
#+name: dis_inva_cmd
 #+begin_src python :noweb yes
  villes = ["Bief de Nérécaille", "Boisclair", "Eaux Fétides", "Gré du vent",
            "Ile des Lames", "Levant", "Haute-Chute", "Marais des Trames",
            "Rive tourmentée", "Val des Larmes", "Falaise du roy"]

  async def autocomp_villes(inter: disnake.ApplicationCommandInteraction, user_input: str):
      return [ville for ville in villes if ville.lower().startswith(user_input.lower())]

  async def tags_from_id(ctx, msg_id):
      msg = await ctx.channel.fetch_message(msg_id)
      selected = await msg.reactions[0].users().flatten()
      return [dtag(u) for u in selected][1:]

  class CompTrigger(disnake.ui.View):
      options = [disnake.SelectOption(label=k, value=v) for k, v in config['gdoc']['strats'].items()]
      options[0].default = True
      def __init__(self, origin, **kwargs):
          super().__init__(**kwargs)
          self.origin = origin
          self.strat = config['gdoc']['strats']['Principale']

      @disnake.ui.select(options=options)
      async def compo(self, select: disnake.ui.Select, inter: disnake.MessageInteraction):
          self.strat=select.values[0]
          await inter.response.defer()

      @disnake.ui.button(label='Composition', style=disnake.ButtonStyle.blurple)
      async def trigger(self, button: disnake.ui.Button, inter: disnake.MessageInteraction):
          #await interaction.delete_original_message()
          await inter.response.defer()
          self.stop()


  @bot.slash_command(
      scope=906630964703289434,
  )
  async def invasion(
          ctx: disnake.ApplicationCommandInteraction,
          ville: str=commands.Param(autocomplete=autocomp_villes)):
      """ Génére un tableau d'inscription dans le channel actuel

          Parameters
          ----------
          ville: La ville où se déroule l'invasion
      """

      embed = Embed(
          title=f'Invasion de {ville}',
          color=2003199,
          description="Réagis avec :ballot_box_with_check: à ce message **uniquement si tu es déjà dans le fort**. Attention, retourne vite en jeu, l'auto-AFK kick est rapide (2min). \n\n Si tu as réagi par erreur, merci de décocher ta réaction. :wink:",
      )
      embed.set_footer(text='Invasion')

      # Envoi du message et ajout de la réaction
      await ctx.send(embed=embed)
      msg = await ctx.original_message()
      await msg.add_reaction('☑')

      # Envoi d'un message caché à l'invocateur
      trigger = CompTrigger(msg.id, timeout=10*60)
      await ctx.send("Calcul", view=trigger, ephemeral=True)

      # Attente du déclanchement pas l'invocateur
      await trigger.wait()

      # Récupération du message originel complet
      msg = await ctx.channel.fetch_message(msg.id)

      selected = await msg.reactions[0].users().flatten()

      selected_tags = [dtag(u) for u in selected if dtag(u) != 'Invasion#5489']
      #selected_tags = [dtag(u) for u in selected][1:]

      # Récupération des donénes du Gdoc roster
      roster = get_roster(config)

      # Joueurs séléctionnés n'ayant pas rempli le Gdoc
      not_registered = [u for u in selected_tags if u not in roster.index]

      # Filtrage du roster avec les joueurs séléctionnés
      roster = roster.filter(items=selected_tags, axis=0).set_index('Pseudo IG')

      add_participation(roster.index)

      strat=trigger.strat

      # Récupération de la strat
      url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={strat}"

      page = pd.read_csv(url)
      strat_df = page.iloc[0:5, 0:10]
      img_url = page.iat[5, 1]

      comp = build_comp(roster, strat_df, config)
      def gen_embed(comp):
          e = Embed(title="Composition d'armée")
          for k, v in comp.iteritems():
              f = ''
              for p in v.to_list():
                  f += str(p) + '\n'
              e.add_field(name=k, value=f, inline=True)
          return e

      embed = gen_embed(comp)
      embed.title = f"Invasion de {ville}, {strat} :"
      #embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)
      embed.color = 2003199
      embed.set_thumbnail(url=img_url)
      await ctx.send(embed=embed, delete_after=60*25)

 #+end_src
** Commande verif
#+name: dis_verif
 #+begin_src python
  @bot.slash_command(
      description="Vérification du Gdoc et mise à jour des rôles",
      scope=906630964703289434,
  )
  async def verif(ctx):
      """ Attribue les rôles
      """

      guild = ctx.guild
      lead_role = guild.get_role(config["ids"]["leads"])

      # Récupération des donénes du Gdoc roster
      roster_df = get_roster(config)
      roster = list(roster_df.index)

      members = {dtag(m): m for m in guild.members}

      role = guild.get_role(config["ids"]["role"])
      verified = [dtag(m) for m in role.members]

      added = []
      wrong = []
      for u in roster:
         if u not in members:
             wrong += [u]
         elif u not in verified:
             if role is None:
                 # Make sure the role still exists and is valid.
                 return

             try:
                 # Finally, add the role.
                 await members[u].add_roles(role)
                 added += [u]
             except discord.HTTPException:
                 # If we want to do something in case of errors we'd do it here.
                 pass

      removed = []
      for u in verified:
          if u not in roster:
              try:
                  # Finally, remove the role.
                  await members[u].remove_roles(role)
                  removed += [u]

                  # Send DM to user
                  embed = Embed.from_dict(config["embeds"]["change"])
                  embed.description += f'{config["gdoc"]["form"]}) ***!***'
                  await members[u].send(embed=embed)
              except discord.HTTPException:
                  # If we want to do something in case of errors we'd do it here.
                  pass

      def add_IG(l, roster_df):
          return [f"{i} | {roster_df.loc[i]['Pseudo IG']}" for i in l]
      wrong = add_IG(wrong, roster_df)
      added = add_IG(added, roster_df)
      embed = Embed()
      embed.title = f'Vérification du gdoc'
      embed.color = 2003199
      #embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)

      embed.add_field(name="Joueurs nouvellement vérifiés", value=list_to_field(added), inline=False)
      embed.add_field(name="Discord tag dans le Gdoc ne correspondant à aucun membre du discord", value=list_to_field(wrong), inline=False)
      embed.add_field(name=f"Joueurs ayant changé de Discord tag (rôle {role} supprimé)", value=list_to_field(removed), inline=False)
      await ctx.channel.send(embed=embed, delete_after=20*60)
      #print(added, wrong)


 #+end_src
** Commande transfert
#+name: dis_transfert
 #+begin_src python

  async def autocomp_sources(ctx: disnake.ApplicationCommandInteraction, user_input: str):
      voices = [v for v in ctx.guild.voice_channels if v.members]
      return [v.name for v in voices if v.name.lower().startswith(user_input.lower())]

  async def autocomp_destinations(ctx: disnake.ApplicationCommandInteraction, user_input: str):
      voices = ctx.guild.voice_channels
      return [v.name for v in voices if v.name.lower().startswith(user_input.lower())]
      #return [ville for ville in villes if user_input.lower() in ville]
  @bot.slash_command()
  async def transfert(ctx: disnake.ApplicationCommandInteraction,
                      source: str=commands.Param(autocomplete=autocomp_sources),
                      destination: str=commands.Param(autocomplete=autocomp_destinations)):
      """Déplace les joueurs d'un salon vocal source à un salon destinatoin

          Parameters
          ----------
          source: La ville où se déroule l'invasion
          destination: La ville où se déroule l'invasion
      """
      voices = {v.name: v for v in ctx.guild.voice_channels}
      dest = voices[destination]
      users = voices[source].members
      await ctx.send(content=f'{len(users)} Utilisateurs vont être déplacés dans le salon ***{destination}***', ephemeral=True)
      [await u.move_to(dest) for u in users]


 #+end_src

** Commande Instance
#+name: dis_instance
 #+begin_src python
  lieux = ["Lazarus", "Gènese", "Sirène"]

  async def autocomp_lieux(inter: disnake.ApplicationCommandInteraction, user_input: str):
      return [l for l in lieux if l.lower().startswith(user_input.lower())]

  @bot.slash_command()
  async def instance(ctx: disnake.ApplicationCommandInteraction,
                     lieu: str=commands.Param(autocomplete=autocomp_lieux),
                     heure: str=commands.Param(default=None),
                     prix: str=commands.Param(default=None)):
      """Crée un panneau d'inscription à une instance

          Parameters
          ----------
          lieu: La ville où se déroule l'instance
          heure: L'heure à laquelle se déroule l'instance
          prix: Le prix par personne, gratuit c'est cool aussi ;)
      """
      embed = Embed()
      embed.title = f'Instance {lieu}'
      embed.description = ''
      if heure:
          embed.description += f' 🕐 {heure}\n'
      if prix:
          embed.description += f' 💰 {prix}\n'
      embed.description += f'Proposée par {ctx.user.mention}\n'
      embed.color = 2003199

      roles = ['🛡', '⚔', '⚔', '⚔','⛑']
      players = ['libre']*len(roles)
      embed.add_field(name="Rôles", value=list_to_field(roles), inline=True)
      embed.add_field(name="Joueurs", value=list_to_field(players), inline=True)
      embed.set_footer(text='Instance')
      # Envoi du message et ajout de la réaction
      await ctx.send(embed=embed)
      msg = await ctx.original_message()


      for r in unique(roles):
          await msg.add_reaction(r)
      await msg.add_reaction('✅')
      await msg.add_reaction('❌')
 #+end_src
** Gestion des réactions aux messages

Certain des messages issus des commandes du bot nécessitent une
analyse des réactions des utilisateurs.

Les réactions aux messages sont centralisées, et un *callback* unique
est appelé dès qu'une utilisateur réagit, indépendamment du
message. Or,nous ne voulons pas analyser les réactions aux messages
qui ne sont pas issus d'une commande du bot.

Il nous faut donc un mécanisme pour identifier si le message attaché
est d'un type intéressant et si oui, comment l'analyser. Il serait
possible de stocker en mémoire tous les messages issus de commandes
envoyés, mais pour me simplifier la vie je préfére embarquer cette
information dans les messages.

Malheureusement, je n'ai pas trouvé de champ non utilisé dans la
classe message. J'ai donc décidé de stocker le type directement dans
le contenu du message. Plus particulièrement dans le *footer* de
l'embed du message.
*** On reaction add
 #+name: on_reaction
  #+begin_src python
   @bot.event
   async def on_reaction_add(reaction, user):
        if user == bot.user:
            return
        if not reaction.message.embeds:
            return
        msg_type = reaction.message.embeds[-1].footer.text

        if msg_type == 'Invasion':
            await check_user_role(reaction, user)
            return
        if msg_type == 'Instance':
            await update_instance(reaction, user)
            return

 #+end_src
*** On reaction remove
 #+name: on_reaction_rm
  #+begin_src python
   @bot.event
   async def on_reaction_remove(reaction, user):
        if user == bot.user:
            return
        if not reaction.message.embeds:
            return
        msg_type = reaction.message.embeds[-1].footer.text
        if msg_type == 'Invasion':
            await update_invasion(reaction)
            return
        if msg_type == 'Instance':
            await update_instance_rm(reaction, user)
            return

 #+end_src
*** On s'assure que le joueur soit enregistré
#+name: check_user
#+begin_src python
  async def update_invasion(reaction):
      selected = await reaction.message.reactions[0].users().flatten()
      embed = reaction.message.embeds[-1]
      embed.clear_fields()
      embed.add_field(name="Enregistrés :", value=len(selected)-1, inline=True)
      await reaction.message.edit(embed=embed)

  async def check_user_role(reaction, user):
      # Récupération des donénes du Gdoc roster
      df = get_roster(config)
      if dtag(user) not in df.index:
          embed = Embed.from_dict(config["embeds"]["dm"])
          embed.description += f'{config["gdoc"]["form"]}) ***!***'
          try:
              await user.send(embed=embed)
          except disnake.errors.HTTPException as e:
              pass
      else:
          guild = reaction.message.guild
          role = guild.get_role(config["ids"]["role"])

          await update_invasion(reaction)

          await user.edit(nick=df.at[dtag(user), "Pseudo IG"])
          if role is None:
              # Make sure the role still exists and is valid.
              return
          try:
              # Finally, add the role.
              await user.add_roles(role)
          except disnake.HTTPException:
              # If we want to do something in case of errors we'd do it here.
              ...
#+end_src

*** Gestion ajout réaction message Instance
#+name: update_instance_add
#+begin_src python
  def instance_data(reaction):
      fields = {e.name: e.value.split('\n') for e in reaction.message.embeds[-1].fields}
      return fields['Rôles'], fields['Joueurs']

  async def update_instance_embed(reaction, roles, joueurs):
      # Récupération et mise à jour du message initial
      embed = reaction.message.embeds[-1]
      embed.clear_fields()
      embed.add_field(name="Rôles", value=list_to_field(roles), inline=True)
      embed.add_field(name="Joueurs", value=list_to_field(joueurs), inline=True)
      await reaction.message.edit(embed=embed)

  async def update_instance(reaction, user, add=True):
      message = reaction.message
      cmd_author = message.interaction.user

      roles, joueurs = instance_data(reaction)

      if reaction.emoji == '✅':
          if user == cmd_author:
              # Create vocal and swap users

              categories = message.guild.categories
              category = disnake.utils.find(lambda c: c.id == 948167052722573322, categories)
              voice = await category.create_voice_channel(f'Instance de {user.display_name}')

              ids = [int(j[3:-1]) for j in joueurs if j != 'libre']

              users = await message.guild.getch_members(ids, presences=True)

              for u in users:
                  if u.voice:
                      await u.move_to(voice)
                  else:
                      invite = await voice.create_invite()
                      await u.send(f"L'instance a démarré, rejoins ici : {invite} ", embed=message.embeds[-1])
              await message.delete(delay=60)
              return

      if reaction.emoji == '❌':
          if user == cmd_author:
              await message.delete()
          return

      if user.mention not in joueurs:
          for i, r in enumerate(roles):
              if reaction.emoji == r and joueurs[i] == 'libre':
                  joueurs[i] = user.mention
                  break

      await update_instance_embed(reaction, roles, joueurs)
#+end_src

*** Gestion annulation réaction message Instance
#+name: update_instance_rm
#+begin_src python

  async def update_instance_rm(reaction, user):
      roles, joueurs = instance_data(reaction)
      # Le joueur est-il séléctionné ?
      if user.mention in joueurs:
          # On le supprime de la liste des joueurs en le remplacant par libre
          for i, r in enumerate(roles):
              if joueurs[i] == user.mention and r==reaction.emoji:
                  joueurs[i] = 'libre'
                  break

          for i, r in enumerate(roles):
              if joueurs[i] == 'libre':
                  disponibles = [d for d in reaction.message.reactions if d.emoji == r][-1]
                  # On récupére les utilisateurs en prennat soint de filtrer le bot
                  disponibles = [u for u in await disponibles.users().flatten() if u != bot.user and u.mention not in joueurs]
                  if disponibles:
                      joueurs[i] = disponibles[0].mention

      await update_instance_embed(reaction, roles, joueurs)

#+end_src

** Gestion des changement d'état vocaux
(aka quand un user change de channel vocal)

#+name: on_voice_state_update
#+begin_src python
  @bot.event
  async def on_voice_state_update(member, before, after):
      if before.channel and before.channel.category_id == 948167052722573322:
          if not before.channel.members:
              await before.channel.delete()

#+end_src
