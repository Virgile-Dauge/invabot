#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+TITLE: Invabot

* Documentation des rôles
#+begin_export html
<script async src="https://nwdb.info/embed.js"></script>
#+end_export
Cette section a pour objectif de présenter les différents rôles utiles
en invasion. Chaque rôle comporte des composantes indispensables,
illustrées par le sigle suivant : /(obligatoire)/. Afin de mieux
maîtriser la répartition des rôles, il sera demandé aux joueurs
d'évaluer leur pertinence pour chacun de ces rôles.

Un joueur peut s'estimer :

- Capable :: S'il répond à tous les critères tagués */(obligatoire)/*
- Opti :: S'il répond a tous les critères tagués */(obligatoire)/* *ET* */(recommandé)/*.

** Arc
- *Objectif* :: DPS les *têtes*, les *boss*, les engins de sièges et
  AoE les trashs, dans cet ordre de priorité.
- *Arme principale* :: Arc 580 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] */(obligatoire)/* et [[https://nwdb.info/db/perk/perkid_weapon_empoweroncrit][Keenly
  Empowered]] */(recommandé)/*. [[https://nwdb.info/build?skills=4-iw75uo-ngewxw][Build arc]] */(recommandé)/*
- *Arme secondaire* :: Arme débuff distance comme la hachette ou la lance avec [[https://nwdb.info/db/perk/perkid_ability_spear_javelin][Sundering Javelin]] sur pièce d'armure */(recommandé)/*
- *Armure et perks* :: Légère avec perks pour l'arc[[https://nwdb.info/db/perk/perkid_ability_bow_poisonshot][ Enfeebling Poison Shot]] et [[https://nwdb.info/db/perk/perkid_ability_bow_rapidshot][Penetrating Rapid Shot]] */(recommandé)/*
[[https://nwdb.info/db/perk/perkid_ability_spear_javelin][      Sundering Javelin]] */(recommandé si lance en secondaire)/*

** Mousquet

- *Objectif* :: DPS les *têtes* et les *boss*, dans cet ordre de priorité.
- *Arme principale* :: Mousquet 570 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] */(obligatoire)/* et
  [[https://nwdb.info/db/perk/perkid_weapon_dmgbasic][Enchanted]] */(recommandé)/*  [[https://nwdb.info/build?skills=6-nm5y04-qtbfgg][Build Mousquet]] */(recommandé)/*
- *Armure et perks* :: Légère avec perks pour le mousquet [[https://nwdb.info/db/perk/perkid_ability_musket_shootersstance][Empowering Shooter's
  Stance]] */(recommandé)/*.

** Anti-Trash

- *Objectif* :: Empêcher les *trash-mobs* d'atteindre les autres joueurs et les portes.
- *Arme principale* :: Hache double 580 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] */(obligatoire)/*
  [[https://nwdb.info/db/item/sapphirecutt4][Pristine Sapphire]] */(obligatoire)/* et [[https://nwdb.info/db/item/sapphirecutt4 [[https://nwdb.info/db/perk/perkid_weapon_empoweroncrit][Keenly Empowered]] (recommandé).
  [[https://nwdb.info/build?skills=8-j1mxog-kc3hhg][Build Hache double]] */(obligatoire)/*
- *Arme secondaire* :: Arme CàC, Marteau pour le contrôle ?
- *Armure et perks* :: Lourde */(recommandé)/* [[https://nwdb.info/db/perk/perkid_ability_greataxe_gravitywell][Insatiable Gravity Well]]
  */(obligatoire)*/ [[https://nwdb.info/db/perk/perkid_ability_greataxe_maelstrom][Enfeebling Maelstrom]] et [[https://nwdb.info/db/perk/perkid_ability_greataxe_whirlwind][Fortifying Whirlwind]]
  */(recommandé)/* et pour de la survivabilité [[https://nwdb.info/db/perk/perkid_armor_defcorrupted][Corrupted Ward]] sur
  quelques pièces */(recommandé)/*

** DPS debuff

- *Objectif* :: Appliquer */rend/* et */weaken/* aux boss et les DPS
- *Arme principale* :: Lance 580 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] */(obligatoire)/* et
  [[https://nwdb.info/db/perk/perkid_weapon_empoweroncrit][Keenly Empowered]] ou [[https://nwdb.info/db/perk/perkid_weaponmelee_dmgback][Rogue]] */(recommandé)/*. [[https://nwdb.info/build?skills=10-l71p4w-tsmm2s][Build lance]]
  */(obligatoire)/*
- *Arme secondaire* :: Arc préféré, mais peut être une arme de CàC.
- *Armure* :: Légère avec perks [[https://nwdb.info/db/perk/perkid_ability_spear_javelin][Sundering Javelin]] */(obligatoire)/*
  [[https://nwdb.info/db/perk/perkid_ability_spear_skewer][Enfeebling Skewer]] */(obligatoire)/* [[https://nwdb.info/db/perk/perkid_ability_spear_perforate][Fortifying Perforate]] */(recommandé)/*
  et pour de la survivabilité [[https://nwdb.info/db/perk/perkid_armor_defcorrupted][Corrupted Ward]] sur quelques pièces */(recommandé)/*

** Pustule boy
- *Objectif* :: Tirer en *priorité sur les pustules* qui se forment
  lors de l'impact d'un bison à l'intérieur du fort. Aider au centre.

- *Arme principale* :: Arme distante */(obligatoire)/*, les armes
  Néant/Arc/Feu */(recommandé)/* sont plus efficaces dans ce rôle
  grâce à une meilleure cadence de tir.
- *Arme secondaire* ::  Arc/Mousquet */(recommandé)/*

** Réparateur
- *Objectif* :: Gérer les ressources et *réparer les portes*.
- *Arme principale* :: Hachette avec [[https://nwdb.info/db/ability/ult_passive_hatchet_immortalwhen0hp][Defy Death]] */(recommandé)/*
- *Arme secondaire* :: Arme avec mobilité */(recommandé)/*

PS: Si vous n'avez jamais joué Hachette, il suffit de débloquer 12
points de compétence. C'est assez rapide et vous n'avez pas besoin
d'une arme haut niveau/particulière.

** Artilleur

- *Objectif* :: Tuer les bombers, les tireurs, les artilleries
  ennemies et les trash mob, en respectant cet ordre de priorité.

- *Arme principale* :: Épée avec la compétence [[https://nwdb.info/db/ability/ultimate_sword_swordmaster][Leadership]] */(obligatoire)/*
- *Arme secondaire* :: Bâton de feu/vie/hachette */(recommandé)/*

PS: Si vous n'avez jamais joué l'épée, il suffit de débloquer 12
points de compétence. C'est assez rapide et vous n'avez pas besoin
d'une arme haut niveau/particulière.
** Heal
- *Objectif* :: Maintenir l'équipe *Anti-trash* en vie en priorité
  puis empêcher les *trash-mobs* d'atteindre les autres joueurs et les
  portes.
- *Arme principale* :: Bâton de vie 580 GS min */(obligatoire)/* avec [[https://nwdb.info/db/perk/perkid_weaponlife_healoutgoing][Blessed]]
  */(recommandé)/*
- *Arme secondaire* :: Hache double avec [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] et [[https://nwdb.info/db/item/ambercutt4][Pristine
  Amber]] */(recommandé)/* [[https://nwdb.info/build?skills=8-j1mxog-kc3hhg][Build Hache double]] */(recommandé)/*

  OU

  Gantelet du néant

- *Armure* :: [[https://nwdb.info/db/perk/perkid_armor_defcorrupted][Corrupted Ward]] sur quelques pièces */(recommandé)/*


** Mage AOE

- *Objectif* :: DPS les *boss* dans les phases de fin, quand ils
  s'accumulent sur les portes.
- *Arme principale* :: Bâton de feu 580 GS min. [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] avec [[https://nwdb.info/db/item/sapphirecutt4][Pristine Sapphire]] */(obligatoire)/*
  et [[https://nwdb.info/db/perk/perkid_weapon_empoweroncrit][Keenly Empowered]] */(recommandé)/*.
- *Arme secondaire possible* :: Mousquet [[https://nwdb.info/db/perk/perkid_weapon_dmgcorrupted][Corrupted Bane]] et [[https://nwdb.info/db/perk/perkid_weapon_dmgbasic][Enchanted]] avec
  [[https://nwdb.info/db/item/sapphirecutt4][Pristine Sapphire]] */(recommandé)/*
  OU
  Gantelet de glace pour bloquer les boss
- *Armure* :: Légère


* Bot
** Concept :

 Le bot à pour objectif de générer une composition d'armée à partir des
 50 joueurs sélectionnés aléatoirement par le jeu.

** Configuration

 La configuration du bot passera par un fichier json unique, contenant
 le corps des différents messages à transmettre ainsi que les adresses
 des Gdoc à lire.
 #+begin_src json :tangle config.json
   {
   "ids": {
       "role": 917546013248606238,
       "leads": 928316217297612810
   },
   "doc":{
       "url": "https://virgile-dauge.github.io/invabot/"
   },
   "imgs": {
       "layout": "https://cdn.discordapp.com/attachments/917547596640296990/922901028519706674/layout.png"
   },
   "embeds": {
       "panneau": {
           "title": "Confirme ta séléction à l'invasion de",
           "color": 2003199,
           "description": "Réagis avec :ballot_box_with_check: à ce message **uniquement si tu es déjà dans le fort**. Attention, retourne vite en jeu, l'auto-AFK kick est rapide (2min). \n\n Si tu as réagi par erreur, merci de décocher ta réaction. :wink: \n\n*(Et si vous aussi vous pensez que bakhu est la meilleure guilde)*"
       },
       "dm": {
           "title": "Dis nous tout !",
           "color": 2003199,
           "description": "Tu es inscrit en invasion, mais tu n'as pas renseigné **les rôles** que tu peux jouer. Il n'est donc par conséquent pas possible de t'assigner un poste automatiquement. Allez, file remplir [ce document]("
       },
       "change": {
           "title": "Tu as changé ton discord TAG :/",
           "color": 2003199,
           "description": "Il faut mettre à jour tes infos. Allez, file remplir [ce document]("
       },
       "help": {
           "title": "Manuel d'utilisation d'invabot",
           "color": 2003199,
           "fields": [{"name": "Blue Team", "value": "Something", "inline" : "True"}]
       }
   },
   "gdoc": {
       "url": "https://docs.google.com/spreadsheets/d/1FgtMvUQbLxP7qvXt2tnVwFFyX9KWnuREHu7o0RtX13M/",
       "strats": {
           "Principale": "Strat_principale",
           "Secours": "Strat_secours"
       },
       "page_roster": "Roster",
       "form": "https://forms.gle/G9LizybajjVxCw6JA"
   }
   }
 #+end_src



** Utilitaires
*** Dépendances
#+begin_src python :tangle bot.py

   import pandas as pd
   from algo import build_comp

#+end_src
*** Chargement de la config

 Le chargement de cette config se fera pour l'instant une seule fois au
 démarrage du bot.
#+name: config
 #+begin_src python :tangle bot.py
   # Chargement de la config du bot
   import json
   with open('config.json', 'r') as datafile:
       config = json.load(datafile)
 #+end_src

 #+begin_src python :tangle bot.py
   # Chargement de la config du bot
   import json
   with open('config.json', 'r') as datafile:
       config = json.load(datafile)
 #+end_src

*** Persistance

 Le chargement des données
#+name: data
 #+begin_src python
  # Chargement de la config du bot
  def load_data(path='data.json'):
      with open(path, 'r') as datafile:
          return json.load(datafile)
  def save_data(data, path='data.json'):
      with open(path, 'w') as datafile:
          json.dump(data, datafile, sort_keys=True, indent=4)
  def add_participation(participants):
      #print(participants)
      data = load_data()
      for p in participants:
          if p in data:
              data[p] +=1
          else:
              data[p] = 1
      #print(data)
      save_data(data)
 #+end_src
*** Chargement du token
#+Name: token
 #+begin_src python :tangle bot.py
   # Chargement du token
   with open('bot.token', 'r') as datafile:
       token = datafile.read()
 #+end_src
*** Identifiant

 Il est nécessaire d'avoir un identifiant unique entre discord et le
 gdoc pour faire le lien. Discord gère les identifiants sous forme d'un
 entier appelé /snowflake/. Toutefois, il est difficilement accessible
 pour les joueurs, et ce sont les joueurs qui vont devoir renseigner
 leur identifiant unique sur le gdoc. Il est donc plus simple
 d'utiliser ici le *discord tag*, par exemple `Virgile#1234`.

 Je propose ici une rapide fonction d'aide pour récupérer le dtag
 depuis un objet /discord.User/ :
 #+name: dtag
 #+begin_src python :tangle bot.py
   def dtag(user):
       return f'{user.name}#{user.discriminator}'
 #+end_src

*** Récupération du roster
#+name: get_roster
 #+begin_src python :tangle bot.py
   def get_roster(config):
       url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={config['gdoc']['page_roster']}"
       #return pd.read_csv(url).iloc[1:, 0:6].dropna().set_index('dtag')
       return pd.read_csv(url).set_index('dtag')
 #+end_src

 #+begin_example
                 Pseudo             0           1     2           3
 dtag
 Chopekk#1234   Chopekk    DPS-Debuff    Mousquet  Heal  Anti-trash
 Virgile#2345  virgilio      Mousquet  Anti-trash  Répa        Arti
 Virgile#3456     Tezig  Lance-flamme  Anti-trash   Arc        Arti
 Carlito#4567      Slua    Anti-trash        Arti  Répa       Aucun
 #+end_example
*** Récupération de la strat

 #+begin_src python :tangle bot.py
   def get_strat(config, strat=None):
       if strat is None:
           url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={config['gdoc']['page_strat']}"
       else:
           url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={config['gdoc']['page_strat']}"
       return pd.read_csv(url).iloc[0:5, 0:12]
 #+end_src

 #+begin_example
      Groupe 1 Groupe 2    Groupe 3 Groupe 4    Groupe 5    Groupe 6    Groupe 7    Groupe 8 Groupe 9     Groupe 10
 0  Anti-Trash      Arc  Anti-Trash      Arc  Anti-Trash    Mousquet  Anti-Trash    Mousquet     Répa  Lance-flamme
 1        Heal      Arc        Heal      Arc        Heal    Mousquet        Heal    Mousquet     Répa  Lance-flamme
 2  DPS-Debuff      Arc  DPS-Debuff      Arc  DPS-Debuff    Mousquet  DPS-Debuff    Mousquet     Répa  Lance-flamme
 3  DPS-Debuff      Arc  DPS-Debuff      Arc  DPS-Debuff  DPS-Debuff  DPS-Debuff  DPS-Debuff     Répa  Lance-flamme
 4        Arti     Arti        Arti     Arti        Arti        Arti        Arti        Arti     Répa  Lance-flamme
 #+end_example



* Algo
Dépendances
#+begin_src python :tangle algo.py
import numpy as np
import pandas as pd
from scipy.optimize import linear_sum_assignment
#+end_src

Récupération du roster de test
 #+begin_src python :tangle algo.py
   def get_test_roster():
       page= 'Roster'
       url = f"https://docs.google.com/spreadsheets/d/1FgtMvUQbLxP7qvXt2tnVwFFyX9KWnuREHu7o0RtX13M/gviz/tq?tqx=out:csv&sheet={page}"
       #return pd.read_csv(url).iloc[:, 0:16].dropna().set_index('dtag')
       return pd.read_csv(url).set_index('dtag')
 #+end_src

#+begin_src python :tangle algo.py
    def get_test_strat():
      page= 'Strat'
      url = f"https://docs.google.com/spreadsheets/d/1vDZ_p6Bq2oyyY0CV1SQ0FBRtJoGbtiurM9cOQWHJ-qo/gviz/tq?tqx=out:csv&sheet={page}"
      return pd.read_csv(url).iloc[0:5, 0:12]
#+end_src

#+RESULTS:
: None

 Identification des Rôles :
 #+begin_src python :tangle algo.py :noweb yes

   def build_comp(roster, strat, config):
       roles = {}
       for index, row in strat.iterrows():
           for v in row:
               v = v.split(' ')[0]
               if v in roles:
                   roles[v] += 1
               else:
                   roles[v] = 1

       max_roles = {k: v.max() for k,v in roster.iteritems()}
       <<cout>>
       <<res>>
       <<comp>>
 #+end_src

Création des colonnes avec les noms de rôles, les lignes avec les noms
de joueurs, et de la matrice de coûts.
 #+name: cout
 #+begin_src python

   cols = [k for k, v in roles.items() for _ in range(v)]
   rows = roster.index

   C = np.zeros((len(rows), len(cols)), dtype=int)

   for i, r in enumerate(rows):
       for j, c in enumerate(cols):
           C[i, j] = roster.at[r, c]
 #+end_src


Résolution du problème d'affectation avec la maximisation suivante :
$$max \sum_{i} \sum_{j} C_{i,j} X_{i,j}$$
#+name: res
#+begin_src python

row_ind, X = linear_sum_assignment(C, maximize=True)
score = C[row_ind, X].sum()
assignent = {p: cols[t] for p, t in zip(rows, X)}

#+end_src

Analyse des résultats
#+begin_src python :tangle no
  for k, v in assignent.items():
      print(k, v, roster.at[k, v])

#+end_src

Remplissage du tableau
#+name: comp
#+begin_src python
  filed_roles = {}
  for k, v in assignent.items():
      #print(k, v)
      if v not in filed_roles:
          filed_roles[v] = [k]
      else:
          filed_roles[v] += [k]

  comp = strat.copy()
  for i, row in comp.iterrows():
      for j, v in row.items():
          label = ''
          if len(v.split(' ')) > 1:
              v, label = v.split(' ')
          if v in filed_roles and filed_roles[v]:
              p = filed_roles[v].pop()
              role_txt = f"[{comp.at[i, j]}]({config['doc']['url']})"
              #if role_txt in config['doc']:
              #    role_txt = f"[{role_txt}]({config['doc'][url]})"
              comp.at[i, j] = f'{p} *{role_txt}* {roster.at[p, v] / max_roles[v]:.1f}'
  return comp
#+end_src

** Test algo

#+begin_src python :tangle algo.py

  if __name__ == '__main__':
      roster = get_test_roster().set_index('Pseudo IG')
      roster.to_csv('roster.csv')
      print(roster)
      strat = get_test_strat()
      strat.to_csv('strat.csv')
      print(strat)
      print(build_comp(roster, strat))
#+end_src
**** Filtrage des joueurs
 #+begin_src python :tangle no
 keys_to_extract = []
 a_subset = {key: players[key] for key in keys_to_extract}
 #+end_src


* TODO bot avec Disnake

** Corp
#+begin_src python :tangle disbot.py :noweb tangle
  import pandas as pd
  from algo import build_comp

  import disnake
  from disnake.ext import commands
  from disnake import Embed, Emoji


  <<dtag>>
  <<get_roster>>
  <<config>>

  def main():
      bot = commands.Bot(
          intents=disnake.Intents().all(),
          test_guilds=[906630964703289434], # Optional
          sync_commands_debug=True
      )
      <<data>>
      <<dis_transfert>>
      <<dis_inva_cmd>>
      <<dis_verif>>
      <<on_reaction>>
      bot.run(token=open("bot.token").read()[:-1])

  if __name__ == "__main__":
      main()
#+end_src

** Commande inva
#+name: dis_inva_cmd
 #+begin_src python :noweb yes
  villes = ["Bief de Nérécaille", "Boisclair", "Eaux Fétides", "Gré du vent",
            "Ile des Lames", "Levant", "Haute-Chute", "Marais des Trames",
            "Rive tourmentée", "Val des Larmes", "Falaise du roy"]

  async def autocomp_villes(inter: disnake.ApplicationCommandInteraction, user_input: str):
      return [ville for ville in villes if ville.lower().startswith(user_input.lower())]

  async def tags_from_id(ctx, msg_id):
      msg = await ctx.channel.fetch_message(msg_id)
      selected = await msg.reactions[0].users().flatten()
      return [dtag(u) for u in selected][1:]

  class CompTrigger(disnake.ui.View):
      options = [disnake.SelectOption(label=k, value=v) for k, v in config['gdoc']['strats'].items()]
      options[0].default = True
      def __init__(self, origin, **kwargs):
          super().__init__(**kwargs)
          self.origin = origin
          self.strat = config['gdoc']['strats']['Principale']

      @disnake.ui.select(options=options)
      async def compo(self, select: disnake.ui.Select, inter: disnake.MessageInteraction):
          self.strat=select.values[0]
          await inter.response.defer()

      @disnake.ui.button(label='CB', style=disnake.ButtonStyle.secondary)
      async def cb(self, button: disnake.ui.Button, inter: disnake.MessageInteraction):
          #msg = await inter.original_message()
          #print(inter.message.id, inter.response.is_done(), msg)
          selected = await tags_from_id(inter, self.origin)
          print(inter.response.is_done())
          #await interaction.edit_original_message(content=f'{len(selected)} Joueurs enregistrés')
          if not inter.response.is_done():
              await inter.response.send_message(content=f'{len(selected)} Joueurs enregistrés')
              print(inter.response.is_done())
          else:
              await inter.edit_original_message(content=f'{len(selected)} Joueurs enregistrés')

      @disnake.ui.button(label='Composition', style=disnake.ButtonStyle.blurple)
      async def trigger(self, button: disnake.ui.Button, inter: disnake.MessageInteraction):
          #await interaction.delete_original_message()
          await inter.response.defer()
          self.stop()


  @bot.slash_command(
      scope=906630964703289434,
  )
  async def invasion(
          ctx: disnake.ApplicationCommandInteraction,
          ville: str=commands.Param(autocomplete=autocomp_villes)):
      """ Génére un tableau d'inscription dans le channel actuel

          Parameters
          ----------
          ville: La ville où se déroule l'invasion
      """

      embed = Embed(
          title=f'Invasion de {ville}',
          color=2003199,
          description="Réagis avec :ballot_box_with_check: à ce message **uniquement si tu es déjà dans le fort**. Attention, retourne vite en jeu, l'auto-AFK kick est rapide (2min). \n\n Si tu as réagi par erreur, merci de décocher ta réaction. :wink:",
      )
      #embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)

      # Envoi du message et ajout de la réaction
      await ctx.send(embed=embed)
      msg = await ctx.original_message()
      await msg.add_reaction('☑')

      # Envoi d'un message caché à l'invocateur
      trigger = CompTrigger(msg.id, timeout=10*60)
      await ctx.send("Calcul", view=trigger, ephemeral=True)

      # Attente du déclanchement pas l'invocateur
      await trigger.wait()

      # Récupération du message originel complet
      msg = await ctx.channel.fetch_message(msg.id)

      selected = await msg.reactions[0].users().flatten()

      selected_tags = [dtag(u) for u in selected if dtag(u) != 'Invasion#5489']
      #selected_tags = [dtag(u) for u in selected][1:]

      # Récupération des donénes du Gdoc roster
      roster = get_roster(config)

      # Joueurs séléctionnés n'ayant pas rempli le Gdoc
      not_registered = [u for u in selected_tags if u not in roster.index]

      # Filtrage du roster avec les joueurs séléctionnés
      roster = roster.filter(items=selected_tags, axis=0).set_index('Pseudo IG')

      add_participation(roster.index)

      strat=trigger.strat

      # Récupération de la strat
      url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={strat}"

      page = pd.read_csv(url)
      strat_df = page.iloc[0:5, 0:10]
      img_url = page.iat[5, 1]

      comp = build_comp(roster, strat_df, config)
      <<gen_embed>>
      embed = gen_embed(comp)
      embed.title = f"Invasion de {ville}, {strat} :"
      #embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)
      embed.color = 2003199
      embed.set_thumbnail(url=img_url)
      await ctx.send(embed=embed, delete_after=60*25)

 #+end_src

** On reaction add
 #+name: on_reaction
  #+begin_src python
   @bot.event
   async def on_reaction_add(reaction, user):
        if user == bot.user:
            return
        print(user)
        # Récupération des donénes du Gdoc roster
        df = get_roster(config)
        if dtag(user) not in df.index:
            embed = Embed.from_dict(config["embeds"]["dm"])
            embed.description += f'{config["gdoc"]["form"]}) ***!***'
            try:
                await user.send(embed=embed)
            except disnake.errors.HTTPException as e:
                pass
        else:
            guild = reaction.message.guild
            role = guild.get_role(config["ids"]["role"])

            await user.edit(nick=df.at[dtag(user), "Pseudo IG"])
            if role is None:
                # Make sure the role still exists and is valid.
                return

            try:
                # Finally, add the role.
                await user.add_roles(role)
            except disnake.HTTPException:
                # If we want to do something in case of errors we'd do it here.
                pass

 #+end_src
https://github.com/DisnakeDev/disnake

** Commande verif
#+name: dis_verif
 #+begin_src python
  @bot.slash_command(
      description="Vérification du Gdoc et mise à jour des rôles",
      scope=906630964703289434,
  )
  async def verif(ctx):
      """ Attribue les rôles
      """

      guild = ctx.guild
      lead_role = guild.get_role(config["ids"]["leads"])

      # Récupération des donénes du Gdoc roster
      roster_df = get_roster(config)
      roster = list(roster_df.index)

      members = {dtag(m): m for m in guild.members}

      role = guild.get_role(config["ids"]["role"])
      verified = [dtag(m) for m in role.members]

      added = []
      wrong = []
      for u in roster:
         if u not in members:
             wrong += [u]
         elif u not in verified:
             if role is None:
                 # Make sure the role still exists and is valid.
                 return

             try:
                 # Finally, add the role.
                 await members[u].add_roles(role)
                 added += [u]
             except discord.HTTPException:
                 # If we want to do something in case of errors we'd do it here.
                 pass

      removed = []
      for u in verified:
          if u not in roster:
              try:
                  # Finally, remove the role.
                  await members[u].remove_roles(role)
                  removed += [u]

                  # Send DM to user
                  embed = Embed.from_dict(config["embeds"]["change"])
                  embed.description += f'{config["gdoc"]["form"]}) ***!***'
                  await members[u].send(embed=embed)
              except discord.HTTPException:
                  # If we want to do something in case of errors we'd do it here.
                  pass

      def list_to_field(l):
          f = 'aucun'
          if l:
              f = ''
              for u in l:
                  f += u + '\n'
          if len(f)>1023:
              return f[:1000]+'...'
          return f

      def add_IG(l, roster_df):
          return [f"{i} | {roster_df.loc[i]['Pseudo IG']}" for i in l]
      wrong = add_IG(wrong, roster_df)
      added = add_IG(added, roster_df)
      embed = Embed()
      embed.title = f'Vérification du gdoc'
      embed.color = 2003199
      #embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)

      embed.add_field(name="Joueurs nouvellement vérifiés", value=list_to_field(added), inline=False)
      embed.add_field(name="Discord tag dans le Gdoc ne correspondant à aucun membre du discord", value=list_to_field(wrong), inline=False)
      embed.add_field(name=f"Joueurs ayant changé de Discord tag (rôle {role} supprimé)", value=list_to_field(removed), inline=False)
      await ctx.channel.send(embed=embed, delete_after=20*60)
      #print(added, wrong)


 #+end_src
** Commande transfert
#+name: dis_transfert
 #+begin_src python

  async def autocomp_sources(ctx: disnake.ApplicationCommandInteraction, user_input: str):
      voices = [v for v in ctx.guild.voice_channels if v.members]
      return [v.name for v in voices if v.name.lower().startswith(user_input.lower())]

  async def autocomp_destinations(ctx: disnake.ApplicationCommandInteraction, user_input: str):
      voices = ctx.guild.voice_channels
      return [v.name for v in voices if v.name.lower().startswith(user_input.lower())]
      #return [ville for ville in villes if user_input.lower() in ville]
  @bot.slash_command()
  async def transfert(ctx: disnake.ApplicationCommandInteraction,
                      source: str=commands.Param(autocomplete=autocomp_sources),
                      destination: str=commands.Param(autocomplete=autocomp_destinations)):
      """Déplace les joueurs d'un salon vocal source à un salon destinatoin

          Parameters
          ----------
          source: La ville où se déroule l'invasion
          destination: La ville où se déroule l'invasion
      """
      voices = {v.name: v for v in ctx.guild.voice_channels}
      dest = voices[destination]
      users = voices[source].members
      await ctx.send(content=f'{len(users)} Utilisateurs vont être déplacés dans le salon ***{destination}***', ephemeral=True)
      [await u.move_to(dest) for u in users]


 #+end_src

* Implémentation Discord.py
 https://discordpy.readthedocs.io/en/stable/

 Création du bot
 #+begin_src python :tangle bot.py :noweb yes
   import discord
   from discord.ext import commands

   intents = discord.Intents.default()
   intents.reactions = True
   intents.members = True
   bot = commands.Bot(command_prefix="!", intents=intents)

   msgs = {}
   msgs_ids = []

   @bot.event
   async def on_ready():
       print('We have logged in as {0.user}'.format(bot))
       game = discord.Game("Venez chez Bakhu")
       await bot.change_presence(status=discord.Status.online, activity=game)
 #+end_src

*** Embed d'erreur
 #+begin_src python :tangle bot.py
   async def send_error_message(ctx, title='Erreur', desc=''):
       """ Génére un embed orange avec le titre et la description fournie et l'envoie sur le ctx donné"""
       embed = discord.Embed(title=title)
       embed.color = 16748319
       embed.description = desc
       await ctx.channel.send(embed=embed, delete_after=10)
       return
 #+end_src
*** Clear
#+name: clear
#+begin_src python :tangle bot.py
   @bot.command()
   async def clear(ctx, opt='me'):
       #global hist
       #await rm_cmd(ctx)
       if opt == 'me':
           deleted = await ctx.channel.purge(check=lambda msg: msg.author == ctx.author)
           await ctx.channel.send('Deleted {} message(s)'.format(len(deleted)), delete_after=2)
           #print(hist[ctx.author])
       elif opt == 'all':
           guild = ctx.guild
           lead_role = guild.get_role(config["ids"]["leads"])

           if ctx.author not in lead_role.members:
               embed = discord.Embed(title='Droits insuffisants')
               embed.color = 16748319
               embed.description = f'Rôle ***{lead_role}*** requis'
               await ctx.channel.send(embed=embed, delete_after=10)
               return

           await ctx.channel.purge()
           global msgs
           msgs = {}
           global msgs_ids
           msgs_ids = []
 #+end_src

#+name: rm_cmd
#+begin_src python :tangle no
    async def rm_cmd(ctx):
      try:
          await ctx.message.delete()
      except Exception as e:
          print(e)
 #+end_src

#+name: add_to_hist
#+begin_src python :tangle no
  def add_to_hist(author, mid):
    global hist
    if author in hist and hist[author]:
       hist[author] += [mid]
    else:
       hist[author] = [mid]
 #+end_src

*** Inva
 Commande d'ajout du panneau d'inscription, sur lequel les joueurs dans
 le fort doivent se signaler sera `!inva nomVille`
 #+begin_src python :tangle bot.py
   @bot.command()
   async def inva(ctx, arg="NomVille"):
       """ Génére un tableau d'inscription dans le channel
       """
       # Suppression du message d'invocation
       await rm_cmd(ctx)

       embed = discord.Embed.from_dict(config["embeds"]["panneau"])
       embed.title += f' {arg}'
       embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)

       msg = await ctx.channel.send(embed=embed, delete_after=60*20)
       await msg.add_reaction('☑')

       #add_to_hist(ctx.author, msg.id)

       author_id = dtag(ctx.author)
       msgs[author_id] = msg.id
       global msgs_ids
       msgs_ids += [msg.id]
       #add_to_hist(ctx.author, msg.id)

 #+end_src
*** Composition d'armée

 La commande de demande de *composition* sera la suivante `!comp`. La
 fonction associée doit récupérer le message /panneau/ à partir de
 l'identité de l'appelant. Puis, récupérer la liste des joueurs qui ont
 réagi sur le panneau.
 #+begin_src python :tangle bot.py :noweb yes
   @bot.command()
   async def comp(ctx, strat='Strat_principale'):
       """ Génére une composition d'armée
       """
       # Suppression du message d'invocation
       await rm_cmd(ctx)

       author_dtag = dtag(ctx.author)
       channel = ctx.channel

       # On s'assure que l'utilisateur qui demande le calcul ait déjà fait la commande principale
       if author_dtag not in msgs:
           await send_error_message(ctx=ctx,
                              title='Pas de tableau correspondant...',
                              desc=f'Laissez le lead calculer la composition ! \n\nSi vous êtes lead, commencez par utiliser la commande : \n `!inva nomville`')
           return

       # Récupération du message avec les réacs
       msg_id = msgs[author_dtag]
       main_msg = await channel.fetch_message(msg_id)

       # Récupération de la liste des users
       selected = await main_msg.reactions[0].users().flatten()
       selected_tags = [dtag(u) for u in selected][1:]
       selected_snow = {t: u.id for t, u in zip(selected_tags, selected)}

       # Récupération des donénes du Gdoc roster
       roster = get_roster(config)

       # Joueurs séléctionnés n'ayant pas rempli le Gdoc
       not_registered = [u for u in selected_tags if u not in roster.index]

       # Filtrage du roster avec les joueurs séléctionnés
       roster = roster.filter(items=selected_tags, axis=0).set_index('Pseudo IG')
       #print(roster)

       if strat not in config['gdoc']['strats']:
           await send_error_message(ctx,
                                    title='Stratégie non trouvée',
                                    desc=f"Le document en ligne ne contient pas de page ***{strat}***")
           return
       # Récupération de la strat
       url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={strat}"
       try:
           page = pd.read_csv(url)
           strat_df = page.iloc[0:5, 0:10]
           img_url = page.iat[5, 1]
           #strat_df = pd.read_csv(url)
           #print(page, img_url)
       except Exception as e:
           await send_error_message(ctx,
                                    title='Erreur accès gdoc',
                                    desc=f"Le document en ligne n'est pas accessible.")
           return
       comp = build_comp(roster, strat_df, config)
       <<gen_embed>>
       embed = gen_embed(comp)
       embed.title = f"Invasion de {main_msg.embeds[0].title.split(' ')[-1]}, {strat} :"
       embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)
       embed.color = 2003199
       embed.set_thumbnail(url=img_url)
       await channel.send(embed=embed, delete_after=60*25)
       #add_to_hist(ctx.author, msg.id)

 #+end_src

#+name: gen_embed
#+begin_src python
  def gen_embed(comp):
     e = Embed(title="Composition d'armée")
     for k, v in comp.iteritems():
         f = ''
         for p in v.to_list():
             f += str(p) + '\n'
         e.add_field(name=k, value=f, inline=True)
     return e


#+end_src

*** Comptage des inscrits

 #+begin_src python :tangle bot.py :noweb yes
   @bot.command()
   async def cb(ctx):
       """ Compte les inscrits enregistrés
       """
       # Suppression du message d'invocation
       await rm_cmd(ctx)

       author_dtag = dtag(ctx.author)
       channel = ctx.channel

       # On s'assure que l'utilisateur qui demande le calcul ait déjà fait la commande principale
       if author_dtag not in msgs:
           await send_error_message(ctx=ctx,
                                 title='Pas de tableau correspondant...',
                                 desc=f'Laissez le lead calculer la composition ! \n\nSi vous êtes lead, commencez par utiliser la commande : \n `!inva nomville`')
           return

       # Récupération du message avec les réacs
       msg_id = msgs[author_dtag]
       main_msg = await channel.fetch_message(msg_id)
       #print(main_msg.embeds[0].title.split(' ')[-1])
       # Récupération de la liste des users
       selected = await main_msg.reactions[0].users().flatten()
       selected_tags = [dtag(u) for u in selected][1:]

       # Récupération des donénes du Gdoc roster
       roster = get_roster(config)

       # Joueurs séléctionnés n'ayant pas rempli le Gdoc
       not_registered = [u for u in selected_tags if u not in roster.index]

       # Filtrage du roster avec les joueurs séléctionnés
       roster = roster.filter(items=selected_tags, axis=0).set_index('Pseudo IG')

       embed = discord.Embed(title=f"Invasion de {main_msg.embeds[0].title.split(' ')[-1]}, **{len(roster)}** enregistrés.")
       embed.color = 2003199
       embed.description = f"S'il y a tout le monde, le lead peut utiliser :\n\n `!comp`"
       embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)
       await ctx.channel.send(embed=embed, delete_after=2)
 #+end_src
*** DM des joueurs qui n'ont pas renseigné leurs rôles

 Cette phase n'est pas absolument nécessaire, mais elle permet de
 notifier directement en message privé les utilisateurs qui se
 signalent dans le fort mais qui n'ont pas correctement rempli le
 gdoc. Cela leur laisse potentiellement le temps de le faire avant que
 le lead demande le calcul de la composition du groupement de défense.
 #+begin_src python :tangle bot.py
   @bot.event
   async def on_reaction_add(reaction, user):
        # On vérifie que la réaction est sur un message panneau
        if reaction.message.id not in msgs_ids:
            return
        if user == bot.user:
            return

        # Récupération des donénes du Gdoc roster
        df = get_roster(config)
        if dtag(user) not in df.index:
            embed = discord.Embed.from_dict(config["embeds"]["dm"])
            embed.description += f'{config["gdoc"]["form"]}) ***!***'
            try:
                await user.send(embed=embed)
            except discord.errors.HTTPException as e:
                pass
        else:
            guild = reaction.message.guild
            role = guild.get_role(config["ids"]["role"])
            if role is None:
                # Make sure the role still exists and is valid.
                return

            try:
                # Finally, add the role.
                await user.add_roles(role)
            except discord.HTTPException:
                # If we want to do something in case of errors we'd do it here.
                pass

 #+end_src

*** Vérification des enregistrés
 #+begin_src python :tangle bot.py
   @bot.command()
   async def verif(ctx):
       """ Attribue les rôles
       """
       print(f'!verif command invoked by {dtag(ctx.author)}')
       # Suppression du message d'invocation
       await rm_cmd(ctx)

       guild = ctx.guild
       lead_role = guild.get_role(config["ids"]["leads"])

       if ctx.author not in lead_role.members:
           await send_error_message(ctx=ctx,
                                 title='Droits insuffisants',
                                 desc=f'Rôle ***{lead_role}*** requis')
           return
       # Récupération des donénes du Gdoc roster
       roster_df = get_roster(config)
       roster = list(roster_df.index)


       members = {dtag(m): m for m in guild.members}

       role = guild.get_role(config["ids"]["role"])
       verified = [dtag(m) for m in role.members]

       added = []
       wrong = []
       for u in roster:
          if u not in members:
              wrong += [u]
          elif u not in verified:
              if role is None:
                  # Make sure the role still exists and is valid.
                  return

              try:
                  # Finally, add the role.
                  await members[u].add_roles(role)
                  added += [u]
              except discord.HTTPException:
                  # If we want to do something in case of errors we'd do it here.
                  pass

       removed = []
       for u in verified:
           if u not in roster:
               try:
                   # Finally, remove the role.
                   await members[u].remove_roles(role)
                   removed += [u]

                   # Send DM to user
                   embed = discord.Embed.from_dict(config["embeds"]["change"])
                   embed.description += f'{config["gdoc"]["form"]}) ***!***'
                   await members[u].send(embed=embed)
               except discord.HTTPException:
                   # If we want to do something in case of errors we'd do it here.
                   pass

       def list_to_field(l):
           f = 'aucun'
           if l:
               f = ''
               for u in l:
                   f += u + '\n'
           if len(f)>1023:
               return f[:1000]+'...'
           return f

       def add_IG(l, roster_df):
           return [f"{i} | {roster_df.loc[i]['Pseudo IG']}" for i in l]
       wrong = add_IG(wrong, roster_df)
       added = add_IG(added, roster_df)
       embed = discord.Embed()
       embed.title = f'Vérification du gdoc'
       embed.color = 2003199
       embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)

       embed.add_field(name="Joueurs nouvellement vérifiés", value=list_to_field(added), inline=False)
       embed.add_field(name="Discord tag dans le Gdoc ne correspondant à aucun membre du discord", value=list_to_field(wrong), inline=False)
       embed.add_field(name=f"Joueurs ayant changé de Discord tag (rôle {role} supprimé)", value=list_to_field(removed), inline=False)
       await ctx.channel.send(embed=embed, delete_after=20*60)
       #print(added, wrong)


 #+end_src
*** Run

 #+begin_src python :tangle bot.py
 bot.run(token)
 #+end_src

* Bot avec interactions
https://discord-interactions.readthedocs.io/en/latest/index.html

** Création et démarrage
 #+begin_src python :tangle bot_slash.py :noweb tangle
   import logging
   import interactions

   from interactions import Embed, Option, Button
   #logging.basicConfig(level=logging.DEBUG)

   bot = interactions.Client(token=open("bot.token").read()[:-1])

   @bot.event
   async def on_ready():
       print("Bot is now online.")

   <<inva_cmd>>
   <<in_callback>>
   <<out_callback>>
   bot.start()
 #+end_src

** Commande panneau
  Commande d'ajout du panneau d'inscription, sur lequel les joueurs dans
 le fort doivent se signaler sera `!inva nomVille`
#+name: inva_cmd
 #+begin_src python
  @bot.command(name="invasion",
      description="Création du panneau d'inscription",
      scope=906630964703289434,
      options=[
          interactions.Option(
              type=interactions.OptionType.STRING,
              name="ville",
              description="Dans quelle ville se passe l'invasion ?",
              required=False,
              #choices=[
                  #interactions.Choice(name="Choose me! :(", value="choice_one")
                  #interactions.Choice(name="Haute-Chute", value="Haute-Chute"),
                  #interactions.Choice(name="Grés-du-vent", value="Grés-du-vent")
              #]
          )
      ]

  )
  async def invasion(ctx: interactions.CommandContext, ville="NomVille"):
      """ Génére un tableau d'inscription dans le channel
      """

      embed = interactions.Embed(
          color= 2003199,
          description="Réagis avec :ballot_box_with_check: à ce message **uniquement si tu es déjà dans le fort**. Attention, retourne vite en jeu, l'auto-AFK kick est rapide (2min). \n\n Si tu as réagi par erreur, merci de décocher ta réaction. :wink:",
          inline=False,
      )
      #embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)

      in_bt = interactions.Button(
          style=interactions.ButtonStyle.PRIMARY,
          label="Inscription",
          custom_id="in_callback",
      )
      out_bt = interactions.Button(
          style=interactions.ButtonStyle.SECONDARY,
          label="Désinscription",
          custom_id="out_callback",
      )
      msg = await ctx.send(f"Invasion de {ville}, inscrit-toi **uniquement si tu es dans le fort !**",
                           embeds=embed,
                           components=[in_bt, out_bt])

      #await msg.add_reaction('☑')

      #add_to_hist(ctx.author, msg.id)

      #author_id = dtag(ctx.author)
      #msgs[author_id] = msg.id
      #global msgs_ids
      #msgs_ids += [msg.id]
      #add_to_hist(ctx.author, msg.id)

 #+end_src

** Callback inscription
#+name: in_callback
 #+begin_src python
  @bot.component("in_callback")
  async def in_callback(ctx: interactions.ComponentContext):
      """ Défini le comportement lorsqu'un joueur s'inscrit
      """
      #print(ctx)
      await ctx.send("Tu es bien inscrit !", ephemeral=True, components=[], embeds=[])

 #+end_src

** Callback desinscription
#+name: out_callback
 #+begin_src python
  @bot.component("out_callback")
  async def out_callback(ctx: interactions.ComponentContext):
      """ Défini le comportement lorsqu'un joueur s'inscrit
      """
      #print(ctx)
      await ctx.send("Tu es bien désinscrit, merci !", ephemeral=True, components=[], embeds=[])

 #+end_src
