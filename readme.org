This file is part of Invabot.

Invabot is free software: you can redistribute it
and/or modify it under the terms of the GNU General
Public License as published by the Free Software
Foundation, either version 3 of the License, or
any later version.

Invabot is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the
implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License
for more details.

You should have received a copy of the GNU General
Public License along with Invabot. If not, see
<https://www.gnu.org/licenses/>

#+PROPERTY: header-args+ :comments both
#+PROPERTY: header-args+ :mkdirp yes
#+PROPERTY: header-args+ :padline yes
#+STARTUP: overview

#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+TITLE: Invabot

* Algorithme d'attribution des r√¥les
Cette section d√©finit l'algorithme d'attribution des r√¥les, qui est
ind√©pendant de /Discord/.

** Principe

Attribuer un r√¥le √† chaque joueur, en optimisant la pertinence totale
des attributions.
** Licence
#+begin_src python :tangle algo.py
# This file is part of Invabot.

# Invabot is free software: you can redistribute it
# and/or modify it under the terms of the GNU General
# Public License as published by the Free Software
# Foundation, either version 3 of the License, or
# any later version.

# Invabot is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE. See the GNU General Public License
# for more details.

# You should have received a copy of the GNU General
# Public License along with Invabot. If not, see
# <https://www.gnu.org/licenses/>

#+end_src

** D√©pendances
#+begin_src python :tangle algo.py
  import numpy as np
  import pandas as pd
  from scipy.optimize import linear_sum_assignment

  from typing import Dict, List, Tuple
  import numpy.typing as npt

  NDArrayInt = npt.NDArray[np.int_]
#+end_src

** Donn√©es d'entr√©e
Les donn√©es d'entr√©es sont :
- un roster :: un ensemble de joueurs repr√©sent√© par une
  [[https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html][DataFrame]]. Chaque ligne de cette structure repr√©sente un joueur
  ainsi que sa comp√©tence (un entier) pour chaque r√¥le pr√©d√©fini.

- une strat√©gie :: un ensemble de r√¥les √† attribuer,
  repr√©sent√© par une [[https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html][DataFrame]], et structur√© sous forme de groupes.

*** Donn√©es de test
 #+begin_src python :tangle algo.py
   def get_test_roster():
       url = "https://docs.google.com/spreadsheets/d/1FgtMvUQbLxP7qvXt2tnVwFFyX9KWnuREHu7o0RtX13M/gviz/tq?tqx=out:csv&sheet=Roster"
       return pd.read_csv(url).set_index('dtag')
 #+end_src
#+begin_src python :tangle algo.py
  def get_test_strat():
      url = "https://docs.google.com/spreadsheets/d/1FgtMvUQbLxP7qvXt2tnVwFFyX9KWnuREHu7o0RtX13M/gviz/tq?tqx=out:csv&sheet=Strat_principale"
      page = pd.read_csv(url)
      return page.iloc[0:5, 0:10]
#+end_src
** Identification des r√¥les √† attribuer

La premi√®re √©tape consiste √† extraire, depuis la strat√©gie d'entr√©e,
les r√¥les √† attribuer.

#+begin_src python :tangle algo.py
  def extraction_roles(strat: pd.DataFrame) -> Dict[str, int]:
      roles = {}
      for index, row in strat.iterrows():
          for v in row:
              v = v.split(' ')[0]
              if v in roles:
                  roles[v] += 1
              else:
                  roles[v] = 1
      return roles
#+end_src

** Matrice de co√ªts
Maintenant que les r√¥les sont d√©termin√©s, l'objectif est d'affecter
pour chacun un joueur. C'est un classique d'optimisation combinatoire,
connu sous le terme de probl√®me d'[[https://en.wikipedia.org/wiki/Assignment_problem][affectation]].

La programmation lin√©aire est une technique √©prouv√©e pour r√©soudre ce
probl√®me. L'id√©e est de repr√©senter le probl√®me par une matrice $C$ de
pertinence (ou de co√ªt si minimisation), o√π chaque √©l√©ment $C_{i,j}$
repr√©sente la pertinence d'attribuer le r√¥le $i$ au joueur $j$.

Nous avons besoin de cr√©er la matrice $C$ ainsi que des labels de
lignes /rows/ et de colonnes /cols/ faisant le lien entre les index
$i$ et $j$ et les noms de r√¥les/joueurs.

 #+name: cout
 #+begin_src python :tangle algo.py
   def matrice_cout(roles: pd.DataFrame, roster: pd.DataFrame) -> Tuple[List[str], List[str], NDArrayInt]:
       cols = [k for k, v in roles.items() for _ in range(v)]
       rows = roster.index

       C = np.zeros((len(rows), len(cols)), dtype=int)

       for i, r in enumerate(rows):
           for j, c in enumerate(cols):
               C[i, j] = int(roster.at[r, c])
       return rows, cols, C
 #+end_src

** R√©solution
Puis, il faut trouver la matrice d'assignation $X$ qui va maximiser la
pertinence totale de la mani√®re suivante :

$$max \sum_{i} \sum_{j} C_{i,j} X_{i,j}$$

Nous utiliserons pour cela la fonction [[https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.linear_sum_assignment.html][linear_sum_assignment]] de
[[https://docs.scipy.org/doc/scipy/index.html][Scipy]]. Ensuite, nous cr√©ons un dictionnaire avec les assignations
choisies.

#+begin_src python :tangle algo.py
  def solve(rows: List[str], cols: List[str], C: NDArrayInt) -> Dict[str, str]:
      row_ind, X = linear_sum_assignment(C, maximize=True)
      # score = C[row_ind, X].sum()
      return {p: cols[t] for p, t in zip(rows, X)}
#+end_src

** Exploitation des r√©sultats
Remplissage de la composition des groupes en fonciton des assignations
calcul√©es.
#+begin_src python :tangle algo.py
  def creation_compo(assignations: Dict[str, str], strat: pd.DataFrame, roster: pd.DataFrame) -> pd.DataFrame:
      filed_roles = {}
      for k, v in assignations.items():
          if v not in filed_roles:
              filed_roles[v] = [k]
          else:
              filed_roles[v] += [k]

      max_roles = {k: v.max() for k,v in roster.iteritems()}

      comp = strat.copy()
      for i, row in comp.iterrows():
          for j, v in row.items():
              label = ''
              if len(v.split(' ')) > 1:
                  v, label = v.split(' ')
              if v in filed_roles and filed_roles[v]:
                  p = filed_roles[v].pop()
                  role_txt = f"[{comp.at[i, j]}]({config['doc']['url']})"
                  comp.at[i, j] = f'{p} *{role_txt}* {roster.at[p, v] / max_roles[v]:.1f}'
      return comp
#+end_src
** Processus complet
 #+begin_src python :tangle algo.py
   def build_comp(roster: pd.DataFrame, strat: pd.DataFrame, config):
       roles = extraction_roles(strat)
       assignation = solve(*matrice_cout(roles, roster))
       return creation_compo(assignation, strat, roster)
 #+end_src
** Test algorithme

#+begin_src python :tangle algo.py
  import json
  <<config>>
  if __name__ == '__main__':
      with open('config.json', 'r') as datafile:
          config = json.load(datafile)
      roster = get_test_roster()
      roster.to_csv('roster.csv')
      print(roster)
      strat = get_test_strat()
      strat.to_csv('strat.csv')
      print(strat)
      print(build_comp(roster, strat, config))
#+end_src


* Bot
** Concept :

 Le bot √† pour objectif de g√©n√©rer une composition d'arm√©e √† partir des
 50 joueurs s√©lectionn√©s al√©atoirement par le jeu.

** Configuration

 La configuration du bot passera par un fichier json unique, contenant
 le corps des diff√©rents messages √† transmettre ainsi que les adresses
 des Gdoc √† lire.
 #+begin_src json :tangle config.json :comments no
   {
   "ids": {
       "role": 917546013248606238,
       "leads": 928316217297612810
   },
   "doc":{
       "url": "https://virgile-dauge.github.io/invabot/"
   },
   "imgs": {
       "layout": "https://cdn.discordapp.com/attachments/917547596640296990/922901028519706674/layout.png"
   },
   "embeds": {
       "panneau": {
           "title": "Confirme ta s√©l√©ction √† l'invasion de",
           "color": 2003199,
           "description": "R√©agis avec :ballot_box_with_check: √† ce message **uniquement si tu es d√©j√† dans le fort**. Attention, retourne vite en jeu, l'auto-AFK kick est rapide (2min). \n\n Si tu as r√©agi par erreur, merci de d√©cocher ta r√©action. :wink: \n\n*(Et si vous aussi vous pensez que bakhu est la meilleure guilde)*"
       },
       "dm": {
           "title": "Dis nous tout !",
           "color": 2003199,
           "description": "Tu es inscrit en invasion, mais tu n'as pas renseign√© **les r√¥les** que tu peux jouer. Il n'est donc par cons√©quent pas possible de t'assigner un poste automatiquement. Allez, file remplir [ce document]("
       },
       "change": {
           "title": "Tu as chang√© ton discord TAG :/",
           "color": 2003199,
           "description": "Il faut mettre √† jour tes infos. Allez, file remplir [ce document]("
       },
       "help": {
           "title": "Manuel d'utilisation d'invabot",
           "color": 2003199,
           "fields": [{"name": "Blue Team", "value": "Something", "inline" : "True"}]
       }
   },
   "gdoc": {
       "url": "https://docs.google.com/spreadsheets/d/1FgtMvUQbLxP7qvXt2tnVwFFyX9KWnuREHu7o0RtX13M/",
       "strats": {
           "Principale": "Strat_principale",
           "Secours": "Strat_secours"
       },
       "page_roster": "Roster",
       "form": "https://forms.gle/G9LizybajjVxCw6JA"
   }
   }
 #+end_src

** Utilitaires
*** Licence
#+begin_src python :tangle bot.py
# This file is part of Invabot.

# Invabot is free software: you can redistribute it
# and/or modify it under the terms of the GNU General
# Public License as published by the Free Software
# Foundation, either version 3 of the License, or
# any later version.

# Invabot is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE. See the GNU General Public License
# for more details.

# You should have received a copy of the GNU General
# Public License along with Invabot. If not, see
# <https://www.gnu.org/licenses/>

#+end_src
*** D√©pendances
#+begin_src python :tangle bot.py
  import json
  import pandas as pd
  from algo import build_comp
#+end_src
*** Chargement de la configuration du bot

 Le chargement de cette config se fera pour l'instant une seule fois au
 d√©marrage du bot.
#+name: config
 #+begin_src python :tangle bot.py
   with open('config.json', 'r') as datafile:
       config = json.load(datafile)
 #+end_src

*** Chargement du token
Le /token discord/ est n√©cessaire pour lier le programme √† l'identit√©
/Discord/ du bot. Il est √©videmment priv√© et *ne dois jamais* √™tre
inclus dans le d√©p√¥t Git.
#+Name: token
 #+begin_src python :tangle bot.py
   # Chargement du token
   with open('bot.token', 'r') as datafile:
       token = datafile.read()
 #+end_src
*** Identifier de mani√®re unique les utilisateurs

 Il est n√©cessaire d'avoir un identifiant unique entre discord et le
 gdoc pour faire le lien. Discord g√®re les identifiants sous forme d'un
 entier appel√© /snowflake/. Toutefois, il est difficilement accessible
 pour les joueurs, et ce sont les joueurs qui vont devoir renseigner
 leur identifiant unique sur le gdoc. Il est donc plus simple
 d'utiliser ici le *discord tag*, par exemple `Virgile#1234`.

 Je propose ici une rapide fonction d'aide pour r√©cup√©rer le dtag
 depuis un objet /discord.User/ :
 #+name: dtag
 #+begin_src python :tangle bot.py
   def dtag(user):
       return f'{user.name}#{user.discriminator}'
 #+end_src

*** R√©cup√©ration du roster
#+name: get_roster
 #+begin_src python :tangle bot.py
   def get_roster(config):
       url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={config['gdoc']['page_roster']}"
       #return pd.read_csv(url).iloc[1:, 0:6].dropna().set_index('dtag')
       return pd.read_csv(url).set_index('dtag')
 #+end_src

 #+begin_example
                 Pseudo             0           1     2           3
 dtag
 Chopekk#1234   Chopekk    DPS-Debuff    Mousquet  Heal  Anti-trash
 Virgile#2345  virgilio      Mousquet  Anti-trash  R√©pa        Arti
 Virgile#3456     Tezig  Lance-flamme  Anti-trash   Arc        Arti
 Carlito#4567      Slua    Anti-trash        Arti  R√©pa       Aucun
 #+end_example
*** R√©cup√©ration de la strat

 #+begin_src python :tangle bot.py
   def get_strat(config, strat=None):
       if strat is None:
           url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={config['gdoc']['page_strat']}"
       else:
           url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={config['gdoc']['page_strat']}"
       return pd.read_csv(url).iloc[0:5, 0:12]
 #+end_src

 #+begin_example
      Groupe 1 Groupe 2    Groupe 3 Groupe 4    Groupe 5    Groupe 6    Groupe 7    Groupe 8 Groupe 9     Groupe 10
 0  Anti-Trash      Arc  Anti-Trash      Arc  Anti-Trash    Mousquet  Anti-Trash    Mousquet     R√©pa  Lance-flamme
 1        Heal      Arc        Heal      Arc        Heal    Mousquet        Heal    Mousquet     R√©pa  Lance-flamme
 2  DPS-Debuff      Arc  DPS-Debuff      Arc  DPS-Debuff    Mousquet  DPS-Debuff    Mousquet     R√©pa  Lance-flamme
 3  DPS-Debuff      Arc  DPS-Debuff      Arc  DPS-Debuff  DPS-Debuff  DPS-Debuff  DPS-Debuff     R√©pa  Lance-flamme
 4        Arti     Arti        Arti     Arti        Arti        Arti        Arti        Arti     R√©pa  Lance-flamme
 #+end_example


** Corp
#+begin_src python :tangle bot.py :noweb tangle
  import pandas as pd
  from algo import build_comp

  import disnake
  from disnake.ext import commands
  from disnake import Embed, Emoji

  import re


  <<dtag>>
  <<get_roster>>
  <<config>>
  def list_to_field(l):
      f = 'aucun'
      if l:
          f = ''
          for u in l:
              f += u + '\n'
          if len(f)>1023:
              return f[:1000]+'...'
          return f

  def unique(l):
      u = []
      for r in l:
          if r not in u:
              u +=[r]
      return u

  def main():
      bot = commands.Bot(
          intents=disnake.Intents().all(),
          test_guilds=[906630964703289434], # Optional
          sync_commands_debug=True
      )
      <<data>>

      <<slash_transfert>>
      <<slash_invasion>>
      <<slash_instance>>
      <<slash_verif>>
      <<slash_collecte>>

      <<check_user>>
      <<update_instance_add>>
      <<update_instance_rm>>
      <<on_reaction>>
      <<on_reaction_rm>>
      <<on_voice_state_update>>
      bot.run(token=open("bot.token").read()[:-1])

  if __name__ == "__main__":
      main()
#+end_src
** Slash commands
*** Commande invasion
#+name: slash_invasion
 #+begin_src python :noweb yes
  villes = ["Bief de N√©r√©caille", "Boisclair", "Eaux F√©tides", "Gr√© du vent",
            "Ile des Lames", "Levant", "Haute-Chute", "Marais des Trames",
            "Rive tourment√©e", "Val des Larmes", "Falaise du roy"]

  async def autocomp_villes(inter: disnake.ApplicationCommandInteraction, user_input: str):
      return [ville for ville in villes if ville.lower().startswith(user_input.lower())]

  async def tags_from_id(ctx, msg_id):
      msg = await ctx.channel.fetch_message(msg_id)
      selected = await msg.reactions[0].users().flatten()
      return [dtag(u) for u in selected][1:]

  class CompTrigger(disnake.ui.View):
      options = [disnake.SelectOption(label=k, value=v) for k, v in config['gdoc']['strats'].items()]
      options[0].default = True
      def __init__(self, origin, **kwargs):
          super().__init__(**kwargs)
          self.origin = origin
          self.strat = config['gdoc']['strats']['Principale']

      @disnake.ui.select(options=options)
      async def compo(self, select: disnake.ui.Select, inter: disnake.MessageInteraction):
          self.strat=select.values[0]
          await inter.response.defer()

      @disnake.ui.button(label='Composition', style=disnake.ButtonStyle.blurple)
      async def trigger(self, button: disnake.ui.Button, inter: disnake.MessageInteraction):
          #await interaction.delete_original_message()
          await inter.response.defer()
          self.stop()


  @bot.slash_command(
      scope=906630964703289434,
  )
  async def invasion(
          ctx: disnake.ApplicationCommandInteraction,
          ville: str=commands.Param(autocomplete=autocomp_villes)):
      """ G√©n√©re un tableau d'inscription dans le channel actuel

          Parameters
          ----------
          ville: La ville o√π se d√©roule l'invasion
      """

      embed = Embed(
          title=f'Invasion de {ville}',
          color=2003199,
          description="R√©agis avec :ballot_box_with_check: √† ce message **uniquement si tu es d√©j√† dans le fort**. Attention, retourne vite en jeu, l'auto-AFK kick est rapide (2min). \n\n Si tu as r√©agi par erreur, merci de d√©cocher ta r√©action. :wink:",
      )
      embed.set_footer(text='Invasion')

      # Envoi du message et ajout de la r√©action
      await ctx.send(embed=embed)
      msg = await ctx.original_message()
      await msg.add_reaction('‚òë')

      # Cr√©ation du vocal
      invasions_cat = 906648457824051252
      category = disnake.utils.find(lambda c: c.id == invasions_cat, ctx.guild.categories)

      await category.create_voice_channel(f'üî© R√©parations {ville}')
      await category.create_voice_channel(f'{ville}', user_limit=99)

      # Envoi d'un message cach√© √† l'invocateur
      trigger = CompTrigger(msg.id, timeout=10*60)
      await ctx.send("Calcul", view=trigger, ephemeral=True)

      # Attente du d√©clanchement pas l'invocateur
      await trigger.wait()

      # R√©cup√©ration du message originel complet
      msg = await ctx.channel.fetch_message(msg.id)

      selected = await msg.reactions[0].users().flatten()

      selected_tags = [dtag(u) for u in selected if dtag(u) != 'Invasion#5489']

      # R√©cup√©ration des don√©nes du Gdoc roster
      roster = get_roster(config)

      # Joueurs s√©l√©ctionn√©s n'ayant pas rempli le Gdoc
      not_registered = [u for u in selected_tags if u not in roster.index]

      # Filtrage du roster avec les joueurs s√©l√©ctionn√©s
      roster = roster.filter(items=selected_tags, axis=0).set_index('Pseudo IG')

      strat=trigger.strat

      # R√©cup√©ration de la strat
      url = f"{config['gdoc']['url']}gviz/tq?tqx=out:csv&sheet={strat}"

      page = pd.read_csv(url)
      strat_df = page.iloc[0:5, 0:10]
      img_url = page.iat[5, 1]

      comp = build_comp(roster, strat_df, config)
      def gen_embed(comp):
          e = Embed(title="Composition d'arm√©e")
          for k, v in comp.iteritems():
              f = ''
              for p in v.to_list():
                  f += str(p) + '\n'
              e.add_field(name=k, value=f, inline=True)
          return e

      embed = gen_embed(comp)
      embed.title = f"Invasion de {ville}, {strat} :"
      #embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)
      embed.color = 2003199
      embed.set_thumbnail(url=img_url)
      await ctx.send(embed=embed, delete_after=60*25)

 #+end_src
*** Commande verif
#+name: slash_verif
 #+begin_src python
  @bot.slash_command(
      description="V√©rification du Gdoc et mise √† jour des r√¥les",
      scope=906630964703289434,
  )
  async def verif(ctx):
      """ Attribue les r√¥les
      """

      guild = ctx.guild
      lead_role = guild.get_role(config["ids"]["leads"])

      # R√©cup√©ration des don√©nes du Gdoc roster
      roster_df = get_roster(config)
      roster = list(roster_df.index)

      members = {dtag(m): m for m in guild.members}

      role = guild.get_role(config["ids"]["role"])
      verified = [dtag(m) for m in role.members]

      added = []
      wrong = []
      for u in roster:
         if u not in members:
             wrong += [u]
         elif u not in verified:
             if role is None:
                 # Make sure the role still exists and is valid.
                 return

             try:
                 # Finally, add the role.
                 await members[u].add_roles(role)
                 added += [u]
             except disnake.HTTPException:
                 # If we want to do something in case of errors we'd do it here.
                 pass

      removed = []
      for u in verified:
          if u not in roster:
              try:
                  # Finally, remove the role.
                  await members[u].remove_roles(role)
                  removed += [u]

                  # Send DM to user
                  embed = Embed.from_dict(config["embeds"]["change"])
                  embed.description += f'{config["gdoc"]["form"]}) ***!***'
                  await members[u].send(embed=embed)
              except disnake.HTTPException:
                  # If we want to do something in case of errors we'd do it here.
                  pass

      def add_IG(l, roster_df):
          return [f"{i} | {roster_df.loc[i]['Pseudo IG']}" for i in l]
      wrong = add_IG(wrong, roster_df)
      added = add_IG(added, roster_df)
      embed = Embed()
      embed.title = f'V√©rification du gdoc'
      embed.color = 2003199
      #embed.set_footer(text=ctx.author.name, icon_url = ctx.author.avatar_url)

      embed.add_field(name="Joueurs nouvellement v√©rifi√©s", value=list_to_field(added), inline=False)
      embed.add_field(name="Discord tag dans le Gdoc ne correspondant √† aucun membre du discord", value=list_to_field(wrong), inline=False)
      embed.add_field(name=f"Joueurs ayant chang√© de Discord tag (r√¥le {role} supprim√©)", value=list_to_field(removed), inline=False)
      await ctx.channel.send(embed=embed, delete_after=20*60)
      #print(added, wrong)


 #+end_src
*** Commande transfert
#+name: slash_transfert
 #+begin_src python

  async def autocomp_sources(ctx: disnake.ApplicationCommandInteraction, user_input: str):
      voices = [v for v in ctx.guild.voice_channels if v.members]
      return [v.name for v in voices if v.name.lower().startswith(user_input.lower())]

  async def autocomp_destinations(ctx: disnake.ApplicationCommandInteraction, user_input: str):
      voices = ctx.guild.voice_channels
      return [v.name for v in voices if v.name.lower().startswith(user_input.lower())]
      #return [ville for ville in villes if user_input.lower() in ville]
  @bot.slash_command()
  async def transfert(ctx: disnake.ApplicationCommandInteraction,
                      source: str=commands.Param(autocomplete=autocomp_sources),
                      destination: str=commands.Param(autocomplete=autocomp_destinations)):
      """D√©place les joueurs d'un salon vocal source √† un salon destinatoin

          Parameters
          ----------
          source: La ville o√π se d√©roule l'invasion
          destination: La ville o√π se d√©roule l'invasion
      """
      voices = {v.name: v for v in ctx.guild.voice_channels}
      dest = voices[destination]
      users = voices[source].members
      await ctx.send(content=f'{len(users)} Utilisateurs vont √™tre d√©plac√©s dans le salon ***{destination}***', ephemeral=True)
      [await u.move_to(dest) for u in users]


 #+end_src

*** Commande Instance
#+name: slash_instance
 #+begin_src python
  donjons = ["Lazarus", "G√®nese", "Dynastie", "Etoile", "Profondeur", "Amrine", "Temp√™te"]
  zones_elites = ["Sir√®ne", "Palais", "Mines", "Myrk", "Malveillance"]
  lieux = donjons + zones_elites
  async def autocomp_lieux(inter: disnake.ApplicationCommandInteraction, user_input: str):
      return [l for l in lieux if l.lower().startswith(user_input.lower())]

  @bot.slash_command()
  async def instance(ctx: disnake.ApplicationCommandInteraction,
                     lieu: str=commands.Param(autocomplete=autocomp_lieux),
                     heure: str=commands.Param(default=None),
                     prix: str=commands.Param(default=None),
                     tanks: int=commands.Param(default=None),
                     dps: int=commands.Param(default=None),
                     heals: int=commands.Param(default=None),
                     mutation: int=commands.Param(default=None)):
      """Cr√©e un panneau d'inscription √† une instance

          Parameters
          ----------
          lieu: La ville o√π se d√©roule l'instance
          heure: L'heure √† laquelle se d√©roule l'instance
          prix: Le prix par personne, gratuit c'est cool aussi ;)
          tanks: Le nombre de tanks attendus
          dps: Le nombre de dps attendus
          heals: Le nombre de heals attendus
          mutation: Le niveau de mutation (si mutation)
      """
      embed = Embed()
      embed.title = f'Instance {lieu}'
      if mutation:
          embed.title += f' M{mutation}'
      embed.description = ''
      if heure:
          embed.description += f' üïê {heure}\n'
      if prix:
          embed.description += f' üí∞ {prix}\n'
      embed.description += f'Propos√©e par {ctx.user.mention}\n'
      embed.color = 2003199

      # Si nombre custom
      if tanks or dps or heals:
          if not tanks:
              tanks = 1
          if not dps:
              dps = 3
          if not heals:
              heals = 1
          roles = ['üõ°']*tanks + ['‚öî']*dps + ['‚õë']*heals
      else:
          roles = ['üõ°', '‚öî', '‚öî', '‚öî','‚õë']

      players = ['libre']*len(roles)
      embed.add_field(name="R√¥les", value=list_to_field(roles), inline=True)
      embed.add_field(name="Joueurs", value=list_to_field(players), inline=True)
      embed.set_footer(text='Instance')
      # Envoi du message et ajout de la r√©action
      await ctx.send(embed=embed)
      msg = await ctx.original_message()


      for r in unique(roles):
          await msg.add_reaction(r)
      await msg.add_reaction('‚úÖ')
      await msg.add_reaction('‚ùå')
 #+end_src
*** Commande event
#+name: slash_collecte
#+begin_src python
  import math
  def progress_bar(percent, full='üü©', empty='‚¨ú'):
      done = math.floor(percent*10)
      return full* done + empty*(10-done) + ' ' + f'{percent*100:.1f}%'

  def display_progress(actuel, objectif):
      def display_num(n):
          s = str(n)
          if s.endswith('000'):
              s = s[:-3] + 'k'
          return s
      return display_num(actuel)+ ' Ã∏ ' + display_num(objectif) + ' ' + progress_bar(actuel/objectif, full='‚ñÜ', empty='‚ñÅ')

  def progress_embed(title, actuel, objectif, contrib={}, top=5):
      embed = disnake.Embed()
      embed.title = title
      embed.description = display_progress(actuel, objectif)

      contrib_str=''
      if contrib:
          s = dict(sorted(contrib.items(), key=lambda item: item[1], reverse=True))
          for k, v in s.items():
              contrib_str += f'{k}  {v}\n'
          embed.add_field('Contributeurs', contrib_str)
      return embed

  class Dropdown(disnake.ui.Select):
    def __init__(self, **kwargs):

        # Set the options that will be presented inside the dropdown
        options = [
            disnake.SelectOption(
                label="1",
            ),
            disnake.SelectOption(
                label="10",
            ),
            disnake.SelectOption(
                label="100",
            ),
            disnake.SelectOption(
                label="1000",
            ),
        ]

        # The placeholder is what will be shown when no option is chosen
        # The min and max values indicate we can only pick one of the three options
        # The options parameter defines the dropdown options. We defined this above
        super().__init__(
            placeholder="Valeur",
            min_values=1,
            max_values=1,
            options=options,
            ,**kwargs
        )

    async def callback(self, interaction: disnake.MessageInteraction):
        await interaction.response.defer()

  class ProgressView(disnake.ui.View):
      def __init__(self, title, objectif):
          super().__init__(timeout=None)
          self.title = title
          self.actual = 0
          self.objectif = objectif
          self.contributors = {}
          #self.add_item(disnake.ui.Button(style=disnake.ButtonStyle.secondary,
          #                                label=display_progress(0, objectif),
          #                                row=0, disabled=True))
          #self.add_item(Dropdown(row=0))

      async def update(self, val, interaction: disnake.MessageInteraction):
          #self.actual = self.actual + int(self.children[-1].values[0])
          self.actual = self.actual + val
          author = interaction.author.mention
          if author not in self.contributors:
              self.contributors[author] = val
          else:
              self.contributors[author] += val
          await interaction.response.edit_message(embed=progress_embed(self.title,
                                                                       self.actual,
                                                                       self.objectif,
                                                                       self.contributors))

      @disnake.ui.button(label="+1", style=disnake.ButtonStyle.green, row=0)
      async def ajout1(self, button: disnake.ui.Button, interaction: disnake.MessageInteraction):
          await self.update(1, interaction)

      @disnake.ui.button(label="+10", style=disnake.ButtonStyle.green, row=0)
      async def ajout10(self, button: disnake.ui.Button, interaction: disnake.MessageInteraction):
          await self.update(10, interaction)

      @disnake.ui.button(label="+100", style=disnake.ButtonStyle.green, row=0)
      async def ajout100(self, button: disnake.ui.Button, interaction: disnake.MessageInteraction):
          await self.update(100, interaction)

      @disnake.ui.button(label="+1000", style=disnake.ButtonStyle.green, row=0)
      async def ajout1000(self, button: disnake.ui.Button, interaction: disnake.MessageInteraction):
          await self.update(1000, interaction)

  @bot.slash_command()
  async def collecte(ctx: disnake.CommandInteraction,
                     item: str,
                     objectif: int):
      """Cr√©√© un √©v√©nement

         Parameters
         ----------
         item: Item d√©sir√©
         objectif: Qauntit√© totale d√©sir√©e
      """
      title = f'Collecte de {item}'
      #await ctx.send('coucou', view=ProgressView(objectif=objectif))
      await ctx.send(embed=progress_embed(title, 0, objectif), view=ProgressView(title=title, objectif=objectif))
#+end_src

** Gestion des r√©actions aux messages

CertainP des messages issus des commandes du bot n√©cessitent une
analyse des r√©actions des utilisateurs.

Les r√©actions aux messages sont centralis√©es, et un *callback* unique
est appel√© d√®s qu'une utilisateur r√©agit, ind√©pendamment du
message. Or,nous ne voulons pas analyser les r√©actions aux messages
qui ne sont pas issus d'une commande du bot.

Il nous faut donc un m√©canisme pour identifier si le message attach√©
est d'un type int√©ressant et si oui, comment l'analyser. Il serait
possible de stocker en m√©moire tous les messages issus de commandes
envoy√©s, mais pour me simplifier la vie je pr√©f√©re embarquer cette
information dans les messages.

Malheureusement, je n'ai pas trouv√© de champ non utilis√© dans la
classe message. J'ai donc d√©cid√© de stocker le type directement dans
le contenu du message. Plus particuli√®rement dans le *footer* de
l'embed du message.
*** On reaction add
 #+name: on_reaction
  #+begin_src python
   @bot.event
   async def on_reaction_add(reaction, user):
        if user == bot.user:
            return
        if not reaction.message.embeds:
            return
        msg_type = reaction.message.embeds[-1].footer.text

        if msg_type == 'Invasion':
            await check_user_role(reaction, user)
            return
        if msg_type == 'Instance':
            await update_instance(reaction, user)
            return

 #+end_src
*** On reaction remove
 #+name: on_reaction_rm
  #+begin_src python
   @bot.event
   async def on_reaction_remove(reaction, user):
        if user == bot.user:
            return
        if not reaction.message.embeds:
            return
        msg_type = reaction.message.embeds[-1].footer.text
        if msg_type == 'Invasion':
            await update_invasion(reaction)
            return
        if msg_type == 'Instance':
            await update_instance_rm(reaction, user)
            return

 #+end_src
*** On s'assure que le joueur soit enregistr√©
#+name: check_user
#+begin_src python
  async def update_invasion(reaction):
      selected = await reaction.message.reactions[0].users().flatten()
      embed = reaction.message.embeds[-1]
      embed.clear_fields()
      embed.add_field(name="Enregistr√©s :", value=len(selected)-1, inline=True)
      await reaction.message.edit(embed=embed)

  async def check_user_role(reaction, user):
      # R√©cup√©ration des don√©nes du Gdoc roster
      df = get_roster(config)
      if dtag(user) not in df.index:
          embed = Embed.from_dict(config["embeds"]["dm"])
          embed.description += f'{config["gdoc"]["form"]}) ***!***'
          try:
              await user.send(embed=embed)
          except disnake.errors.HTTPException as e:
              pass
      else:
          guild = reaction.message.guild
          role = guild.get_role(config["ids"]["role"])

          await update_invasion(reaction)

          await user.edit(nick=df.at[dtag(user), "Pseudo IG"])
          if role is None:
              # Make sure the role still exists and is valid.
              return
          try:
              # Finally, add the role.
              await user.add_roles(role)
          except disnake.HTTPException:
              # If we want to do something in case of errors we'd do it here.
              ...
#+end_src

*** Gestion ajout r√©action message Instance
#+name: update_instance_add
#+begin_src python
  def instance_data(reaction):
      fields = {e.name: e.value.split('\n') for e in reaction.message.embeds[-1].fields}
      return fields['R√¥les'], fields['Joueurs']

  async def update_instance_embed(reaction, roles, joueurs):
      # R√©cup√©ration et mise √† jour du message initial
      embed = reaction.message.embeds[-1]
      embed.clear_fields()
      embed.add_field(name="R√¥les", value=list_to_field(roles), inline=True)
      embed.add_field(name="Joueurs", value=list_to_field(joueurs), inline=True)
      await reaction.message.edit(embed=embed)

  async def update_instance(reaction, user, add=True):
      message = reaction.message
      cmd_author = message.interaction.user

      roles, joueurs = instance_data(reaction)

      if reaction.emoji == '‚úÖ':
          if user == cmd_author:
              # Create vocal and swap users

              categories = message.guild.categories
              category = disnake.utils.find(lambda c: c.id == 948167052722573322, categories)
              voice = await category.create_voice_channel(f'Instance de {user.display_name}')

              ids = [int(re.sub("[^0-9]", "", j)) for j in joueurs if j != 'libre']

              users = await message.guild.getch_members(ids)

              for u in users:
                  if u.voice:
                      await u.move_to(voice)
                  else:
                      invite = await voice.create_invite()
                      await u.send(f"L'instance a d√©marr√©, rejoins ici : {invite} ", embed=message.embeds[-1])
              await message.delete(delay=60)
              return

      if reaction.emoji == '‚ùå':
          if user == cmd_author:
              await message.delete()
          return

      if user.mention not in joueurs:
          for i, r in enumerate(roles):
              if reaction.emoji == r and joueurs[i] == 'libre':
                  joueurs[i] = user.mention
                  break

      await update_instance_embed(reaction, roles, joueurs)
#+end_src

*** Gestion annulation r√©action message Instance
#+name: update_instance_rm
#+begin_src python
  async def update_instance_rm(reaction, user):
      roles, joueurs = instance_data(reaction)
      # Le joueur est-il s√©l√©ctionn√© ?
      if user.mention in joueurs:
          # On le supprime de la liste des joueurs en le remplacant par libre
          for i, r in enumerate(roles):
              if joueurs[i] == user.mention and r==reaction.emoji:
                  joueurs[i] = 'libre'
                  break

          for i, r in enumerate(roles):
              if joueurs[i] == 'libre':
                  disponibles = [d for d in reaction.message.reactions if d.emoji == r][-1]
                  # On r√©cup√©re les utilisateurs en prennat soint de filtrer le bot
                  disponibles = [u for u in await disponibles.users().flatten() if u != bot.user and u.mention not in joueurs]
                  if disponibles:
                      joueurs[i] = disponibles[0].mention

      await update_instance_embed(reaction, roles, joueurs)

#+end_src

** Gestion des changement d'√©tat vocaux
(aka quand un user change de channel vocal)

#+name: on_voice_state_update
#+begin_src python
  @bot.event
  async def on_voice_state_update(member, before, after):
      pve_cat = 919868329521455135
      invasions_cat = 906648457824051252
      to_purge = [pve_cat, invasions_cat]

      invasions_waiting = 971423215744348240
      pve_creation = 971424838860292096
      protected = [invasions_waiting, pve_creation]
      if before.channel and before.channel.category_id in to_purge:
          if not before.channel.members and before.channel.id not in protected:
              await before.channel.delete()
      if after.channel and after.channel.id == pve_creation:
          voice = await after.channel.category.create_voice_channel(f'Salon cr√©√© par {member.display_name}')
          await member.move_to(voice)

#+end_src


* Test ui

** Modal (sorte de formulaire)
#+begin_src python
  class MyModal(disnake.ui.Modal):
      def __init__(self) -> None:
          components = [
              disnake.ui.TextInput(
                  label="Name",
                  placeholder="The name of the tag",
                  custom_id="name",
                  style=disnake.TextInputStyle.short,
                  max_length=50,
              ),
              disnake.ui.TextInput(
                  label="Description",
                  placeholder="The description of the tag",
                  custom_id="description",
                  style=disnake.TextInputStyle.short,
                  min_length=5,
                  max_length=50,
              ),
              disnake.ui.TextInput(
                  label="Content",
                  placeholder="The content of the tag",
                  custom_id="content",
                  style=disnake.TextInputStyle.paragraph,
                  min_length=5,
                  max_length=1024,
              ),
          ]
          super().__init__(title="Create Tag", custom_id="create_tag", components=components)

      async def callback(self, inter: disnake.ModalInteraction) -> None:
          embed = disnake.Embed(title="Tag Creation")
          for key, value in inter.text_values.items():
              embed.add_field(name=key.capitalize(), value=value, inline=False)
          await inter.response.send_message(embed=embed)

      async def on_error(self, error: Exception, inter: disnake.ModalInteraction) -> None:
          await inter.response.send_message("Oops, something went wrong.", ephemeral=True)

  @bot.slash_command()
  async def testmodal(ctx: disnake.CommandInteraction):
      """Cr√©√© un √©v√©nement

         Parameters
         ----------

      """
      await ctx.response.send_modal(modal=MyModal())
#+end_src
